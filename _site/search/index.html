<!DOCTYPE html>

<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="stylesheet" href="/css/screen.css">
	<link rel="apple-touch-icon" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" href="/touch-icon.png" sizes="192x192">
	<link rel="icon" type="image/png" href="/images/favicon.png">
	<link rel="stylesheet"
		href="//fonts.googleapis.com/css?family=Merriweather:400italic,400,300italic,300,700,700italic|Open+Sans:400italic,600italic,700italic,700,600,400|Inconsolata:400,700">

	

	<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Search | Base</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="Search" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Knowledge base template for Jekyll." />
<meta property="og:description" content="Knowledge base template for Jekyll." />
<link rel="canonical" href="http://localhost:4000/search/" />
<meta property="og:url" content="http://localhost:4000/search/" />
<meta property="og:site_name" content="Base" />
<script type="application/ld+json">
{"description":"Knowledge base template for Jekyll.","headline":"Search","@type":"WebPage","url":"http://localhost:4000/search/","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/images/sensebox_logo.svg"}},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

	<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Base" />

	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
</head>



<body class="">
	<header>
		<div class="wrapper">
			<section class="top-bar">
				<div class="logo"><a href="/"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#"
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg"
	xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
	xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" id="svg3336" version="1.1"
	inkscape:version="0.91 r13725" xml:space="preserve" width="59.352432mm" height="59.350437mm"
	viewBox="0 0 210.3039 210.29684" sodipodi:docname="sensebox_sticker_randlos.svg">
	<metadata id="metadata3342">
		<rdf:RDF>
			<cc:Work rdf:about="">
				<dc:format>image/svg+xml</dc:format>
				<dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
				<dc:title></dc:title>
			</cc:Work>
		</rdf:RDF>
	</metadata>
	<defs id="defs3340">
		<clipPath clipPathUnits="userSpaceOnUse" id="clipPath3372">
			<path d="M 1776.56,314.355 1577.99,115.773 1379.41,314.355 1577.99,512.93 1776.56,314.355" id="path3374"
				inkscape:connector-curvature="0" />
		</clipPath>
	</defs>
	<sodipodi:namedview pagecolor="#ffffff" bordercolor="#666666" borderopacity="1" objecttolerance="10"
		gridtolerance="10" guidetolerance="10" inkscape:pageopacity="0" inkscape:pageshadow="2"
		inkscape:window-width="2560" inkscape:window-height="1385" id="namedview3338" showgrid="false" units="mm"
		fit-margin-top="0" fit-margin-left="0" fit-margin-bottom="0" fit-margin-right="0" inkscape:zoom="2.8284271"
		inkscape:cx="96.486743" inkscape:cy="50.741222" inkscape:window-x="0" inkscape:window-y="27"
		inkscape:window-maximized="1" inkscape:current-layer="g3344" />
	<g id="g3344" inkscape:groupmode="layer" inkscape:label="ink_ext_XXXXXX"
		transform="matrix(1.25,0,0,-1.25,-144.87458,197.27671)">
		<g id="g4162">
			<path
				d="m 236.25729,25.809652 c -9.41744,8.915872 -22.084,14.430114 -36.05095,14.430465 -14.08981,3.52e-4 -26.84929,-5.570861 -36.27475,-14.569288 l 36.08553,-36.086939 36.2403,36.225907"
				style="fill:#4ebe4b;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3354"
				inkscape:connector-curvature="0" />
			<path
				d="m 200.30182,117.74887 c -11.35741,2.9e-4 -21.85074,3.73524 -30.34036,10.00385 l 30.06823,30.06865 30.3324,-30.33324 c -8.44695,-6.11398 -18.82147,-9.73954 -30.06027,-9.73926"
				style="fill:#fff200;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3356"
				inkscape:connector-curvature="0" />
			<path
				d="m 196.62929,105.2736 c 0.52962,-3.27507 -1.68587,-6.326391 -4.93931,-6.839326 -3.25343,-0.519279 -6.31206,1.699746 -6.82474,4.933296 -0.52961,3.26321 1.68588,6.32428 4.93932,6.83551 3.24919,0.53284 6.31207,-1.68788 6.82473,-4.92948"
				style="fill:#45beed;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3358"
				inkscape:connector-curvature="0" />
			<path
				d="m 196.62993,80.152143 c 0.53808,-3.256854 -1.68588,-6.317921 -4.93931,-6.825761 -3.25344,-0.539623 -6.3036,1.684495 -6.82474,4.926516 -0.52962,3.264901 1.68587,6.32597 4.93083,6.838898 3.25768,0.531147 6.32055,-1.686193 6.83322,-4.939653"
				style="fill:#45beed;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3360"
				inkscape:connector-curvature="0" />
			<path
				d="m 216.02407,58.889433 c 0.51267,-3.247108 -1.68587,-6.308171 -4.95625,-6.834233 -3.25768,-0.50785 -6.30361,1.696353 -6.82475,4.944733 -0.52962,3.263205 1.68587,6.312834 4.93931,6.833817 3.25344,0.532839 6.3036,-1.689583 6.84169,-4.944317"
				style="fill:#45beed;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3362"
				inkscape:connector-curvature="0" />
			<path
				d="m 221.97942,92.07404 c 0.52114,-3.236517 -1.68588,-6.29801 -4.94779,-6.824072 -3.24919,-0.53114 -6.3036,1.687887 -6.83321,4.94474 -0.52962,3.251766 1.69859,6.312837 4.93931,6.834234 3.2619,0.524367 6.31208,-1.696353 6.84169,-4.954902"
				style="fill:#45beed;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3364"
				inkscape:connector-curvature="0" />
			<path
				d="m 254.26095,43.693851 -10.90039,10.891908 11.28511,11.285536 -22.57927,5.73e-4 -7.81588,7.824367 7.59542,7.60009 23.00713,-5.81e-4 -11.50172,11.517849 10.91234,10.892857 29.8791,-29.879533 -29.88183,-30.133049"
				style="fill:#45beed;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3366"
				inkscape:connector-curvature="0" />
			<g transform="matrix(0.42362617,-1.0656099e-5,-1.0656099e-5,0.42362617,-468.45117,-59.452381)" id="g3368">
				<g id="g3370" clip-path="url(#clipPath3372)">
					<path
						d="m 1413.79,344.719 -8.58,-8.582 c 6.05,-6.059 9.02,-13.887 9.04,-21.824 -0.02,-7.938 -2.99,-15.758 -9.02,-21.797 -6.06,-6.043 -13.89,-9.02 -21.82,-9.036 -7.95,0.016 -15.78,2.993 -21.84,9.047 -6.04,6.047 -9.02,13.871 -9.03,21.805 0.01,7.934 2.99,15.754 9.03,21.805 l 0.31,0.304 -0.32,-0.308 c 6.07,6.047 13.9,9.027 21.84,9.039 7.94,-0.016 15.76,-2.984 21.8,-9.031 l 0.01,-0.004 8.58,8.582 8.58,8.574 c -10.72,10.75 -24.9,16.164 -38.97,16.148 -14.07,0.016 -28.25,-5.406 -38.99,-16.136 l 0.32,0.316 -0.32,-0.324 c -10.74,-10.727 -16.15,-24.902 -16.14,-38.965 -0.01,-14.062 5.4,-28.238 16.14,-38.969 10.74,-10.746 24.93,-16.168 39,-16.152 14.07,-0.012 28.24,5.406 38.98,16.141 10.73,10.722 16.14,24.894 16.13,38.961 0.01,14.062 -5.4,28.246 -16.15,38.984 l 0.32,-0.317 -0.32,0.313 -8.58,-8.574"
						style="fill:#4abeea;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3376"
						inkscape:connector-curvature="0" />
					<path
						d="m 1444.18,375.129 -8.58,-8.582 c 14.45,-14.457 21.62,-33.277 21.63,-52.215 -0.01,-18.937 -7.19,-37.762 -21.63,-52.215 -14.44,-14.429 -33.28,-21.609 -52.22,-21.625 -18.93,0.016 -37.75,7.18 -52.2,21.625 -14.45,14.453 -21.61,33.266 -21.63,52.188 0.02,18.937 7.2,37.761 21.65,52.215 14.46,14.453 33.28,21.632 52.22,21.648 18.92,-0.016 37.72,-7.18 52.18,-21.621 l 8.58,8.582 8.58,8.582 c -19.13,19.129 -44.29,28.738 -69.34,28.727 -25.08,0.011 -50.26,-9.618 -69.38,-28.754 -19.14,-19.121 -28.77,-44.305 -28.76,-69.379 -0.01,-25.055 9.6,-50.223 28.74,-69.352 19.13,-19.137 44.3,-28.742 69.36,-28.73 25.08,-0.012 50.26,9.605 69.38,28.73 19.13,19.129 28.76,44.309 28.74,69.379 0.02,25.066 -9.6,50.246 -28.74,69.379 l -8.58,-8.582"
						style="fill:#4abeea;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3378"
						inkscape:connector-curvature="0" />
					<path
						d="m 1474.57,405.523 -8.58,-8.582 c 22.85,-22.851 34.22,-52.664 34.23,-82.589 -0.01,-29.942 -11.4,-59.778 -34.23,-82.625 -22.84,-22.832 -52.67,-34.207 -82.61,-34.219 -29.92,0.012 -59.74,11.375 -82.59,34.219 -22.84,22.839 -34.2,52.644 -34.22,82.566 0.02,29.945 11.4,59.781 34.24,82.637 22.84,22.832 52.67,34.211 82.61,34.222 29.92,-0.011 59.73,-11.371 82.57,-34.211 l 0,0 8.58,8.582 8.58,8.579 c -27.51,27.535 -63.68,41.336 -99.73,41.324 -36.07,0.012 -72.25,-13.813 -99.77,-41.336 -27.54,-27.527 -41.36,-63.719 -41.35,-99.797 -0.01,-36.051 13.79,-72.219 41.33,-99.73 27.52,-27.536 63.7,-41.34 99.75,-41.329 36.07,-0.011 72.25,13.809 99.77,41.329 27.53,27.527 41.35,63.71 41.34,99.789 0.02,36.054 -13.79,72.23 -41.34,99.753 l 0.45,-0.449 -0.45,0.446 -8.58,-8.579"
						style="fill:#4abeea;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3380"
						inkscape:connector-curvature="0" />
					<path
						d="m 1395.06,317.23 c 1.37,-8.496 -4.38,-16.41 -12.83,-17.746 -8.44,-1.359 -16.37,4.414 -17.72,12.797 -1.37,8.465 4.4,16.41 12.83,17.735 8.44,1.375 16.37,-4.375 17.72,-12.786"
						style="fill:#45beed;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3382"
						inkscape:connector-curvature="0" />
				</g>
			</g>
		</g>
	</g>
</svg></a></div>
				<a class="nav-toggle" id="open-nav" href="#">&#9776;</a>
<nav>
	
	

	
	<a href="/" class="">Tutorials</a>
	
	

	
	<a href="/videos/" class="">Videos</a>
	
	

	
	<a href="/faq/" class="">FAQ</a>
	
</nav>
			</section>
			<section class="hero_search">
				<h1>senseBox Docs</h1>
				<p>Alles was du für deine senseBox benötigst</p>
				

<form action="/search/" method="get">
	<input type="search" name="q"  placeholder="Wonach möchtest du suchen?"
		autofocus>
	<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
	<input type="submit" value="Search" style="display: none;">
</form>
			</section>
		</div>

	</header>
	<section class="content">
		<div class="wrapper">
			<p><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for "<strong id="search-query"></strong>"</span></p>
<ul id="search-results"></ul>

<script>
	window.data = {
		
			
				
					
					
					"sensoren-sensoren-umweltsensor": {
						"id": "sensoren-sensoren-umweltsensor",
						"title": "Umweltsensor",
						"categories": "Sensoren",
						"url": " /sensoren/sensoren-umweltsensor/",
						"content": "Mit dem Sensor BME680 kannst du eine verschiedene Auswahl an Phänomenen messen. Lufttemperatur, relative Luftfeuchtigkeit, Luftdruck und Luftqualität können mit dem BME680 bestimmt werden. Er ist also ein echter Alleskönner.\n\n\n\nTechnische Details\n\n  Schnelle Reaktionszeit von weniger als 10 Sekunden\n  “Plug-in-and-Go” senseBox kompatibel\n  Abweichung bei Gasmessungen von +-15%\n\n\nAnschluss und Programmierung\n\nMit dem mitgelieferten Verbindungskabel kannst du deinen Gassensor mit dem “I2C”-Port der senseBoxMCU verbinden. \nIst dies erledigt können wir nun im Programmcode den Sensor initialisieren und uns die ersten Messwerte ausgeben lassen.\n\nAchtungDer BME Gassensor ist nicht mit dem BMP280 Luftdrucksensor kompatibel. Das heißt du kannst nur einen der beiden gleichzeitig anschließen und auslesen!\n\nAls erstes muss die Bibliothek geladen und eine Instanz des Sensors erstellt werden.\n\n#include &lt;SenseBoxMCU.h&gt;\n\nBME680_Class BME680;\n\nvoid setup(){\n    // Normalen seriellen Port initialisieren \n    Serial.begin(9600);\n    while(!Serial);\n\n    // Starten des Sensors\n    BME680.begin(I2C_STANDARD_MODE);\n    delay(2000);\n\n    // Oversampling der Sensoren festlegen\n    BME680.setOversampling(TemperatureSensor, Oversample16);\n    BME680.setOversampling(HumiditySensor, Oversample16);\n    BME680.setOversampling(PressureSensor, Oversample16);\n    Serial.println(F(\"- Setting IIR filter to a value of 4 samples\"));\n    // IIR Filter auf 4 Werte setzen\n    BME680.setIIRFilter(IIR4);\n    BME680.setGas(320, 150);\n}\n\nvoid loop(){\n    // Variable um Messwerte zu speichern\n    static int32_t temperature, humidity, pressure, gas;\n\n    // Aktuelle Messwerte auslesen und speichern\n    BME680.getSensorData(temperature, humidity, pressure, gas); \n    \n    // rel. Luftfeuchte in milli-prozent\n    Serial.print(humidity / 1000.0, 2);                      \n    Serial.print(F(\"%rel. Luftfeuchte \"));\n    \n    // Luftdruck in Hectopascals\n    Serial.print(pressure / 100.0, 2);                       \n    Serial.print(F(\"hPa \"));\n\n    // Luftqualität in mOhm\n    Serial.print(gas / 100.0, 2);                            \n    Serial.println(F(\"mOhm\"));\n    delay(5000);\n}"
					}
					
				
			
		
			
				
					,
					
					"sensoren-sensoren-truebner": {
						"id": "sensoren-sensoren-truebner",
						"title": "Bodenfeuchte- und Temperatursensor",
						"categories": "Sensoren",
						"url": " /sensoren/sensoren-truebner/",
						"content": "Bodentemperatur- &amp; Feuchtigkeitssensor\n\nDer truebner SMT50 ist ein kapazitiver Bodentemperatur- und Feuchtigkeitssensor und eignet sich daher gut für diverse Anwendung im heimischen Garten. Kapazitive Bodenfeuchtesensoren erzeugen ein elektrisches Feld um ihre Messelektroden herum. Das Feld dringt in den umgebenden Boden ein. Die Messelektronik des Sensors ermittelt die resultierende elektrische Kapazität der Elektroden. Je höher der Wassergehalt im Boden ist,desto größer wird die Messkapazität des Sensors.\n\n\n\nTechnische Details\n\n  Versorgungsspannung: 3.3 - 30 VDC (Gleichspannung)\n  Stromaufnahme ca. 2.7 mA (gemessen bei 12VDC)\n  Messbereich volumetrischer Wassergehalt: 0 – 50 % (bei +/- 3% Genauigkeit)\n  Messbereich Temperatur: -20 bis +85 °C (bei +/- 1,0°C Genauigkeit)\n  Messverfahren: FDR (Frequency Domain Response)\n  Messsignal: symmetrisch, bipolar differentiell\n\n\nMaße\n\n  Abmessungen: ca. 13,5 cm x 2,15 cm\n  Gewicht inkl. 10m Kabel: ca. 235 g\n\n\nProgrammierung (Arduino)\n\nProgrammierung (Blockly)"
					}
					
				
			
		
			
				
					,
					
					"sensoren-sensoren-temperatur-luftfeuchte": {
						"id": "sensoren-sensoren-temperatur-luftfeuchte",
						"title": "Temperatur- und Luftfeuchtigkeitssensor",
						"categories": "Sensoren",
						"url": " /sensoren/sensoren-temperatur-luftfeuchte/",
						"content": "Temperatur- und Luftfeuchtesensor\nDer HDC1080 ist ein digitaler Feuchtigkeits- und Temperatursensor. Der Sensor hat eine hohe Genauigkeit und eine sehr geringe Stromaufnahme und passt dadurch ideal zur senseBox. Die Sensoren sind ab Werk kalibirert und können direkt eingesetzt werden.\n\n\n\nTechnische Information\n\n\n  “Plug-in-and-Go” senseBox kompatibel\n  Relative Luftfeuchte (RH) Betriebsbereich 0% bis 100%\n  14 Bit Messauflösung\n  Relative Luftfeuchte Genauigkeit ±4%\n  Temperatur Genauigkeit ±0.2°C\n  2100nA Stromzufuhr\n  Betriebsspannung 2.7 V bis 5.5 V\n  I2C Schnittstelle\n\n\nProgrammierung\n\n#include \"SenseBoxMCU.h\"\n#include &lt;Adafruit_HDC1000.h&gt;\n#include &lt;SPI.h&gt;\n\nHDC1080 hdc;\n\nvoid setup(){\n    Serial.begin(9600);\n    hdc.begin();\n}\n\nvoid loop(){\n    Serial.print(\"Temperature: \");\n    Serial.println(hdc.getTemperature());\n    Serial.print(\"Humidity: \");\n    Serial.println(hdc.getHumidity());\n}"
					}
					
				
			
		
			
				
					,
					
					"sensoren-sensoren-luftdruck-temperatur": {
						"id": "sensoren-sensoren-luftdruck-temperatur",
						"title": "Luftdruck- und Temperatursensor",
						"categories": "Sensoren",
						"url": " /sensoren/sensoren-luftdruck-temperatur/",
						"content": "Dieser Sensor misst den Luftdruck und die Temperatur und basiert auf dem BMP280 Sensor von Bosch.\n\n\n\nTechnische Informationen\n\n\n  “Plug-in-and-Go” senseBox kompatibel\n  Betriebsdruck 300 bis 1100 hPa\n  Relative Präzision ±0.12 hPa\n  Absolute Präzision ±1 hPa\n  Betriebsversorgungsstrom 2.7μA bei 1 Hz Sampling Frequenz\n  Maße: 25mm x 25mm x 9mm\n  Gewicht: 2,4 g\n\n\nProgrammierung\n\n#include \"SenseBoxMCU.h\"\n#include &lt;SPI.h&gt;\n\nBMP280 bmp_sensor;\n\nvoid setup() {\n  Serial.begin(9600);\n  bmp_sensor.begin();\n}\n\nvoid loop() {\n    Serial.print(\"Pressure: \");\n    Serial.println(bmp_sensor.getPressure());\n    Serial.print(\"Temperature: \");\n    Serial.println(bmp_sensor.getTemperature());\n    Serial.print(\"Altitude: \");\n    Serial.println(bmp_sensor.getAltitude(1000));\n}\n\n\nProgrammierung (Blockly)\n\nIn Blockly kann der Sensor über folgenden Block ausgelesen werden:\n\n\n\nIm Block kannst du zwischen Luftdruck und Temperatur auswählen."
					}
					
				
			
		
			
				
					,
					
					"sensoren-sensoren-lautstaerke": {
						"id": "sensoren-sensoren-lautstaerke",
						"title": "Umweltsensor",
						"categories": "Sensoren",
						"url": " /sensoren/sensoren-lautstaerke/",
						"content": "Lautstärkesensor\nDer DFRobot SEN0232 misst die Lautstärke und gibt die Messwerte in Dezibel aus.\n\n\n\nTechnische Informationen\n\n\n  Maße: 60mm x 43mm x 9mm\n  “Plug-in-and-Go” senseBox kompatibel\n  Eingangsspannung: 3,3-5V\n  Ausgangsspannung: 0,6-2,6V\n  Messspanne: zwischen 30dBA und 130 dBA akkurat\n  Messintervall: 125ms\n\n\n\n\nProgrammierung (Arduino)\n\nIm ersten Code-Snippet wird lediglich die Eingangsspannung ausgelesen und in Dezibel konvertiert. Der Wert wird auf der Konsole in Arduino angezeigt.\nSind diese halbwegs nachvollziehbar - werden größer wenn man z.B. in der Nähe des Sensors klatscht und werden dementsprechend kleiner, wenn keine wahrnehmbare Geräuschkulisse vorliegt - dann ist der Sensor einsatzbereit.\n#define SoundSensorPin A1  //this pin read the analog voltage from the sound level meter\n#define VREF  5.0  //voltage on AREF pin,default:operating voltage\n\nvoid setup()\n{\n    Serial.begin(115200);\n}\n\nvoid loop()\n{\n    float voltageValue,dbValue;\n    voltageValue = analogRead(SoundSensorPin) / 1024.0 * VREF;\n    dbValue = voltageValue * 50.0;  //convert voltage to decibel value\n    Serial.print(dbValue,1);\n    Serial.println(\" dBA\");\n    delay(125);\n}\n\n\nProgrammierung (Blockly)"
					}
					
				
			
		
			
				
					,
					
					"sensoren-sensoren-helligkeit-uv": {
						"id": "sensoren-sensoren-helligkeit-uv",
						"title": "Helligkeits- und UV-Sensor",
						"categories": "Sensoren",
						"url": " /sensoren/sensoren-helligkeit-uv/",
						"content": "Auf diesem senseBox-Bauteil sind zwei Sensoren zusammengelegt.\n\nDie Lichtintensität wird mit dem TSL45315-Sensor von AMS-TAOS gemessen. Dieser Sensor erkennt die Lichtverhältnissen ähnlich dem menschlichen Auge und gibt die Helligkeitswerte direkt in Lux, mit großem Dynamikbereich (3 Lux bis 220k Lux), aus.\n\nDer zweite Sensor ist ein Vishay VEML6070 Ultravioletter (UV)-Lichtsensor. Dieser wandelt die Intensität des UV-Lichts der Sonne in digitale Daten um. Der Sensor hat eine hervorragende UV-Empfindlichkeit und Linearität über Filtron™-Technologie. Er hat eine gute UV-Strahlungsmessung auch bei langer Sonnen-UV-Belastung und kann exzellenter Temperaturschwankungen ausgleichen.\n\n\n\nTechnische Details\n\nBelichtungssensor\n\n\n  3,3V - 5V tolerantes I2C/TWI Interface\n  Eingangsspannungsbereich: 3,3V - 5V\n  on-board 2,5V Spannungsregler\n  on-board Pegelwandler\n\n\nUV-Sensor\n\n\n  Betriebsspannung: 2,7V - 5,5V I2C Interface\n  Unterstützt Quittierungsfunktion (Active Acknowledge-Funktion)\n  Temperaturkompensation: -40°C bis +85°C\n  Software-Abschaltregelung für Immunität bei flackernden Leuchtstofflampen\n\n\nMaße\n\n  25mm x 25mm x 9mm\n  Gewicht: 2,5 g\n\n\nProgrammierung\n\n#include \"SenseBoxMCU.h\"\n#include &lt;SPI.h&gt;\n\nTSL45315 tsl;\nVEML6070 veml;\n\nvoid setup() {\n    Serial.begin(9600);\n    tsl.begin();\n    veml.begin();\n}\n\nvoid loop() {\n    Serial.print(\"Illuminance: \");\n    Serial.println(tsl.getIlluminance());\n    Serial.print(\"UV-Intensity: \");\n    Serial.println(veml.getUvIntesity());\n}"
					}
					
				
			
		
			
				
					,
					
					"sensoren-sensoren-gps": {
						"id": "sensoren-sensoren-gps",
						"title": "GPS",
						"categories": "Sensoren",
						"url": " /sensoren/sensoren-gps/",
						"content": "Das GPS-Modul empfängt die Position (Längengrad/Breitengrad/Höhe) der senseBox. Diese kann für mobile Anwendungen, z.B. die mobile Datenübertragung auf die openSenseMap, genutzt werden. Dieser Sensor ist kompatibel mit den gängingen GNS Systemen (GPS, QZSS, GLONASS, BeiDou, Galileo) und basiert auf dem u-blox CAM-M8Q Multi GNSS Modul.\n\n\n\nDer GPS Sensor wird an einen I2C-Port angeschlossen.\n\nTechnische Details\n\n  “Plug-in-and-Go” senseBox kompatibel durch Breakout-Board mit JST-Anschluss\n  Simultanempfang von GPS, QZSS, GLONASS, BeiDou\n  Navigationsempfindlichkeit von –167 dBm\n  Empfänger: 72-Kanal u-blox M8\n  Update-Rate: Single GNSS - bis zu 18Hz, Dual GNSS bis zu 10Hz\n  Stromaufnahme: 30mA im Dauerbetrieb bzw. 10mA Power Save Mode 1Hz bei 3V\n\n\nProgrammierung\n\n#include &lt;senseBoxIO.h&gt;\n#include &lt;TinyGPS++.h&gt;\n#include &lt;SPI.h&gt;\n#include &lt;Wire.h&gt;\n\nWire.requestFrom(0x42,10);\nwhile (Wire.available())\n    gps.encode(Wire.read());\n\n\nProgrammierung (Blockly)\n\nIn Blockly kann der Sensor über folgenden Block ausgelesen werden:\n\nIm Block kannst du zwischen Luftdruck und Temperatur auswählen."
					}
					
				
			
		
			
				
					,
					
					"sensoren-sensoren-feinstaub": {
						"id": "sensoren-sensoren-feinstaub",
						"title": "Feinstaubsensor",
						"categories": "Sensoren",
						"url": " /sensoren/sensoren-feinstaub/",
						"content": "Mit diesem Sensor SDS011 ist es möglich die Feinstaubkonzentration in der Luft zu bestimmen. Der Sensor gibt zwei Werte aus: Die Konzentration von PM2.5 (Partikel &lt; 2.5 um) und PM10 (Partikel &lt; 10 um). Dieser Sensor ist mit einem kleinen Ventilator ausgestattet, um Luft anzusaugen. In seinem Inneren befindet sich ein Laser, der zusammen mit einer Photodiode die Anzahl der Partikel misst. Die Ergebnisse der Messungen werden in µg/m³ (Mikrogramm pro Kubikmeter) angegeben.\n\n\n\nTechnische Details\n\n  “Plug-in-and-Go” senseBox kompatibel\n  Schnelle Reaktionszeit von weniger als 10 Sekunden\n  Hohe Auflösung bis zu 0.3µg/m3\n  Mehrfach wissenschaftliche Prüfung der Datengenauigkeit\n\n\nProgrammierung (Arduino)\n\nIst dies erledigt können wir nun im Programmcode den Sensor initialisieren und uns die ersten Messwerte ausgeben lassen.\n\nAls erstes muss eine Instanz des Sensors erstellt werden. Dazu erstellen wir noch 2 Variablen in denen wir unsere beiden Messwerte für PM10 und PM2.5 speichern.\n\n#include \"SenseBoxMCU.h\"\n#include &lt;SPI.h&gt;\n#include &lt;Wire.h&gt;\n\nSDS011 my_sds(Serial1) // Serial1 gibt hier den Seriellen Port an, an dem du den Sensor angeschlossen hast\nfloat p10,p25\n\n```arduino\nvoid setup(){\n    // Normalen seriellen Port initialisieren \n    Serial.begin(9600);\n    while(!Serial);\n    // Seriellen Port an dem unsere Sensor angeschlossen ist initialisieren\n    Serial1.begin(9600);\n    delay(5000);\n}\n\nvoid loop(){\n    // Variablen den gemessenen Feinstaubwerte zuweisen\n    p10 = my_sds.getPm10();\n    p25 = my_sds.getPm25();\n    //Werte in der Konsole drucken\n    Serial.println(\"P2.5: \"+String(p25));\n    Serial.println(\"P10:  \"+String(p10));\n    delay(1000);\n}\n\n\nProgrammierung (Blockly)"
					}
					
				
			
		
			
				
					,
					
					"opensensemap-opensensemap-register": {
						"id": "opensensemap-opensensemap-register",
						"title": "Registrieren einer neuen senseBox",
						"categories": "openSenseMap",
						"url": " /opensensemap/opensensemap-register/",
						"content": "Um eine neue senseBox auf der openSenseMap zu registrieren, muss zunächst unter Anmelden ein Nutzer-Account erstellt werden.\nAnschließend ist unter dem User-Logo oben rechts das Dashboard zu finden, über welches senseBoxen hinzugefügt und verwaltet werden können.\n\nUnter Neue senseBox kann nun eine neue senseBox registriert werden. Die folgenden Angaben sind notwendig:\n\n\n  Name der senseBox: z.B. der Standort\n  Aufstellungsort: dient der Filterung von Boxen\n  Standort: kann über die Karte ausgewählt werden\n  Modell: bestimmt die Sensorkonfiguration\n\n\nEs gibt eine Vorauswahl für verschiedene Modelle.\nFalls eine nicht vorhandene Sensorkonfiguration vorliegt, können einzelne Sensoren unter Manuelle Konfiguration von Hand hinzugefügt werden.\nWie dies im Detail funktioniert ist unter Andere Plattformen beschrieben.\n\nNachdem die Registrierung abgeschlossen wurde, wird ein Arduino-Sketch angezeigt, welcher die angegebenen Sensoren ausliest und deren Daten regelmäßig zur openSenseMap überträgt.\nUm diesen auf die senseBox zu übertragen, wird die Arduino IDE benötigt, eine exemplarische Installations-Anleitung für die senseBox:home ist hier zu finden.\n\nErweiterte Konfiguration\nEs besteht die Möglichkeit neben der HTTP REST API auch andere Schnittstellen zur Datenübertragung zu nutzen.\nEinstellungen hierfür müssen unter dem entsprechenden Reiter im Abschnitt Erweitert vorgenommen werden.\nDetaillierte Anleitungen dazu sind hier zu finden:\n\n\n  MQTT\n  TheThingsNetwork"
					}
					
				
			
		
			
				
					,
					
					"opensensemap-opensensemap-mqtt": {
						"id": "opensensemap-opensensemap-mqtt",
						"title": "MQTT Integration",
						"categories": "openSenseMap",
						"url": " /opensensemap/opensensemap-mqtt/",
						"content": "Diese Anleitung beschreibt die Möglichkeit, Messwerte über MQTT an die openSenseMap zu senden. Die openSenseMap ist in der Lage, sich als MQTT Client mit einem öffentlichen MQTT Broker zu verbinden. Einen eigenen MQTT Broker bietet die openSenseMap nicht an. Der openSenseMap MQTT Client verbindet sich, wenn nicht anders in den Verbindungseinstellungen angegeben, mit einer 13 Stelligen Id mit prefix osem_ gefolgt von 8 zufälligen Ziffern und Buchstaben von A bis F.\n\nJe registrierter senseBox müssen separate MQTT Einstellungen vorgenommen werden. Für eine Verbindung mit einem Broker können die folgenden Parameter angegeben werden. Alle angegeben Einstellungen werden in der Datenbank der openSenseMap gespeichert. Es bietet sich also an, eigene Zugangsdaten einzurichten.\n\nURL\nDie Adresse zum MQTT Broker. Sollte mit mqtt:// oder ws:// beginnen. Sollte der MQTT Broker Authentifizierung mittels Nutzername und Passwort benötigen, kann dieser in der URL kodiert werden. Die URL sollte dann wie folgt aussehen: mqtt://username:password@hostname.of.mqtt.broker\n\nTopic\nDas MQTT Topic unter dem die openSenseMap Nachrichten empfangen soll. Zum Beispiel home/temperatures/outside\n\nNachrichtenformat\nHier sollte zwischen json und csv ausgewählt werden. Die Formate entsprechen JSON-Array und csv dokumentiert in docs.opensensemap.org.\n\nDekodierungsoptionen\nErwartet ein JSON Objekt. Nur für Nachrichtenformat json: Erlaubt es, unter dem Schlüssel jsonPath einen JSONPath Ausdruck anzugeben, welches die Position der JSON kodierten Daten angibt. Beispiel: {\"jsonPath\":\"$.payload_fields\"}\n\nVerbindungsoptionen\nErwartet ein JSON Objekt. Erlaubt es, dem MQTT Client Verbindungsoptionen zu übergeben. Die Schlüssel keepAlive, reschedulePings, clientId, username und password von https://github.com/mqttjs/MQTT.js#client sind erlaubt."
					}
					
				
			
		
			
				
					,
					
					"opensensemap-opensensemap-manage": {
						"id": "opensensemap-opensensemap-manage",
						"title": "Verwalten von Boxen",
						"categories": "openSenseMap",
						"url": " /opensensemap/opensensemap-manage/",
						"content": "Jeder registrierte Nutzer kann beliebig viele Boxen auf der openSenseMap verwalten.\nWenn die Einstellungen einer Box nachträglich geändert oder der Sketch heruntergeladen werden sollen ist dies über das Dashboard möglich.\nDieses ist in der Menuleiste unter dem User-Icon verfuegbar, sobald ein Nutzer eingeloggt ist:\n\n\n\nIm Dashboard können…\n\n\n  neue Boxen registriert werden,\n  bestehende Boxen angepasst oder entfernt werden,\n  Sketches zur Programmierung einer Box heruntergeladen werden.\n\n\nsenseBox anpassen\nDurch Klick auf den ÄNDERN-Button einer Box im Dashboard können beliebige Eigenschaften dieser Box nachträglich verändert werden.\nNachdem in einem der Abschnitte Änderungen vorgenommen wurden, werden diese durch Klick auf das Diskettensymbol oben rechts übernommen.\n\n\n  Hinweis: Wenn die Sensorkonfiguration geändert wurde, muss der Programmcode der senseBox in den allermeisten Fällen ebenfalls aktualisiert werden. Dieser ist unter dem Reiter *Skript zu finden, um ihn in die Arduino IDE zu kopieren. Falls die WiFi-Version der senseBox verwendet wird, muss erneut die SSID und das WiFi Passwort im Sketch ersetzt werden!*\n\n\nsenseBox löschen\nFalls eine senseBox nicht mehr verwendet wird, oder die Messungen dieser Box von der openSenseMap entfernt werden sollen, kann diese entfernt werden.\nDazu muss im Bearbeitungsmodus (s.o.) im Reiter Allgemein unter dem Feld “senseBox löschen” der Wert DELETE eingetragen werden.\nAnschließend erscheint unter dem Feld ein Button, durch welchen die senseBox und ihre Messungen gelöscht werden.\n\n\n  Achtung: Hierdurch werden neben der senseBox alle hinterlegten Sensordaten unwiderruflich entfernt! Da die Messungen auch für eine Nachträgliche Datenauswertung wertvoll sein können, sollte abgewägt werden ob die senseBox gelöscht werden sollte."
					}
					
				
			
		
			
				
					,
					
					"opensensemap-opensensemap-luftdaten": {
						"id": "opensensemap-opensensemap-luftdaten",
						"title": "luftdaten.info",
						"categories": "openSenseMap",
						"url": " /opensensemap/opensensemap-luftdaten/",
						"content": "Die Feinstaub Sensoren des OK Lab Stuttgart (Luftdaten.info) erlauben es, die gemessenen Daten auch an die openSenseMap zu senden. Um die Daten an die openSenseMap zu senden muss zu allererst herausgefunden werden, welche Sensoren am Feinstaubsensor verwendet werden. Dies kann man am besten in dem Webinterface des Feinstaubsensors nachsehen. (Abb. 1)\n\nDanach muss eine senseBox auf der openSenseMap mit der gerade nachgesehenen Konfiguration registriert werden.\nSollten bei der Registrierung die falschen Sensoren ausgewählt worden sein, ist es am einfachsten die Box einfach wieder zu löschen und mit der korrekten Sensorkonfiguration neu zu registrieren.\n\n1. Neue senseBox registrieren\nErstellen einer neuen senseBox unter: registrieren\n\n  User, Standort, Aufstellungsort und Namen ausfüllen. Gruppenkennzeichnung könnte z.B.: Luftdaten sein.\n  Unter dem Punkt “Hardware” im Schritt “meine senseBox” das Feld “luftdaten.info” ausklappen und die passende Sensorkonfiguration auswählen. (Abb. 2)\n  Registrierung abschließen.\n  Wichtig: senseBox ID kopieren. Dies ist eine 24 Zeichen lange Zeichenkette die ungefähr so aussieht: 58a88c6b650831d8a3625e01\n  Wenn eine korrekte E-Mailadresse angegeben wurde, kommt die senseBox ID auch nochmal per Mail. (zum Beispiel: Deine senseBox-ID lautet: 58a88c6b650831d8a3625e01)\n\n\n2. Feinstaub Sensor konfigurieren\nDer Feinstaub Sensor von Luftdaten.info lässt sich bequem über eine Webseite konfigurieren. Hierfür muss zuerst die IP des Geräts im WLAN ausfindig gemacht werden. Dies gelingt am besten entweder durch ablesen im WLAN-Router.\n\n\n  Mit dem Browser die Konfigurationsseite des Feinstaubsensors aufrufen.\n  Unter dem Punkt Weitere APIs einen Haken bei An openSenseMap senden machen. In das Feld senseBox-ID die eigene senseBox-ID eintragen.\n  Ganz unten auf der Seite auf Speichern klicken\n\n\nFertig\nDer Feinstaubsensor sollte nun seine Daten an die openSenseMap senden.\n\nAbbildung 1: Webinterface Feinstaubsensor\n\n\nAbbildung 2: Registrierung openSenseMap"
					}
					
				
			
		
			
				
					,
					
					"opensensemap-opensensemap-hackair": {
						"id": "opensensemap-opensensemap-hackair",
						"title": "hackAIR",
						"categories": "openSenseMap",
						"url": " /opensensemap/opensensemap-hackair/",
						"content": "Es besteht die Möglichkeit die gemessenen Daten der hackAIR home Sensoren (Version 2) auch an die openSenseMap zu senden.\n\nDazu musst du zuerst dein hackAIR Sensor, wie folgt zusammenbauen und den hackair-v2-advanced aufspielen.\n\nDanach steht dir die openSenseMap Konfiguration im Webinterface zur Verfügung. (Abb. 1)\n\nDanach muss eine senseBox auf der openSenseMap mit der korrekten Hardware registriert werden.\n\n1. Neue senseBox registrieren\n\n  User, Standort, Aufstellungsort und Namen ausfüllen. Gruppenkennzeichnung könnte z.B.: hackAIR sein.\n  Unter dem Punkt “Hardware” im Schritt “meine senseBox” das Feld “hackAIR” ausklappen und die passende Sensorkonfiguration auswählen. (Abb. 2)\n  Registrierung abschließen.\n  Wichtig: senseBox ID kopieren. Dies ist eine 24 Zeichen lange Zeichenkette die ungefähr so aussieht: 58a88c6b650831d8a3625e01\n  Wichtig: access token kopieren. Dies ist eine 64 Zeichen lange Zeichenkette.\n  Wenn eine korrekte E-Mailadresse angegeben wurde, kommt die senseBox ID auch nochmal per Mail. (zum Beispiel: Deine senseBox-ID lautet: 58a88c6b650831d8a3625e01)\n\n\n2. hackAIR Gerät konfigurieren\nDer hackAIR home v2 Sensor lässt sich bequem über eine Webseite konfigurieren. Dazu schließt ihr das Gerät am Strom an.\nDanach sollte ein offenes Netzwerk mit dem Namen ESP-wemos verfügbar sein. Danach müsst ihr noch folgende Schritte durchführen:\n\n\n  Mit dem Browser die Konfigurationsseite des hackAIR home v2 aufrufen (http://192.168.4.1).\n  Unter dem Punkt Configure WiFi tragt ihr im Feld openSenseMap senseBox ID die senseBox-ID ein.\n  Unter dem Punkt Configure WiFi tragt ihr im Feld senseBox access token den access token ein\n  Ganz unten auf der Seite auf Save klicken\n\n\nFertig\nDer hackAIR home v2 Sensor sollte nun die Daten an die openSenseMap senden.\n\nAbbildung 1: Webinterface Feinstaubsensor\n\n\nAbbildung 2: Registrierung openSenseMap"
					}
					
				
			
		
			
				
					,
					
					"opensensemap-opensensemap-download": {
						"id": "opensensemap-opensensemap-download",
						"title": "Datendownload",
						"categories": "openSenseMap",
						"url": " /opensensemap/opensensemap-download/",
						"content": "Es bestehen mehrere Möglichkeiten Sensordaten von der openSenseMap herunterzuladen.\nAbhängig von der Fragestellung bietet sich je eine Option an.\nBei denen von der SenseBox aufgenommenen Daten handelt es sich um OpenData, das heißt sie stehen für alle Nutzer zur freien Verfügung.\n\nDaten zu einer Box\nUnter https://archive.opensensemap.org wird ein Archiv für sämtliche Messungen in der openSenseMap Datenbank geführt.\nHier sind nach Tag und Box gegliederte Messwerte als CSV beziehungsweise ZIP-Archiv verfügbar.\n\nFilter\n\nDurch einen Klick auf den Reiter “Filter” in der openSenseMap kannst du dir zunächst optional spezische Dinge für deine Suche und den anschließenden Download der Daten vorfiltern lassen.\nSolltest du nach einem Namen filtern, kannst du auch die Werte einer einzelnen SenseBox herunterladen.\nDas der Filter aktiv ist, erkennst du an einem roten Dreick unter dem “Reiter” Namen\n\n\n\nGrapische Darstellung von Daten\n\nNeben der Funktion zum Filtern kannst du dir auch die Statistiken der einzelnen Boxen anzeigen lassen, indem du einfach auf eine beliebige Box in der Karte klickst, woraufhin du dann in der Sidebar die Statistiken auswählen \nkannst, die du angezeigt bekommen möchtest.\n\n##Download\n\nWenn du auf der Seite der openSenseMap den Reiter “Datendownload” auswählst, kannst du eine Reihe von räumlichen und Zeitlichen Filtern auf die bereits von den SenseBoxen gemessenen Werte anwenden.\n\n\n\nZeitraum auswählen\nZunächst solltest du einen Zeitraum auswählen, von welchem du die Daten angezeigt haben möchtest.\nDies geht entweder manuell, oder du wählst zwischen “letzte 24 Stunden”,\n“Letzte Woche” oder “Letzter Monat”.\n\nGruppieren nach…\nJetzt wählst du aus, ob du die Daten gemittelt haben möchtest. Hierbei kannst du wieder einen Zeitraum auswählen.\nAlternativ ist es aber auch möglich, dir die Rohdaten ausgeben zu lassen.\n\nOperation\nJetzt kannst du unter “Operation” entscheiden, welche Funktion du auf die Werte anwenden möchtest.\nHierbei kannst du dir zum Beispiel das Maximum oder Minimum von gemessenen Tempertaturen berechnen lassen.\n\nWähle einen Sensor\nHier kannst du nun einen Sensor auswählen, von dem du die gewünschten Werte, mit den Filtern, die du vorher ausgewählt hast, angezeigt haben möchtest.\n\nColumns\nKlicke auf den Button “Columns” um auswählen zu können, welche zusätzlichen Informationen du zu deinen Werten bekommen möchtest.\n\n\n  Achtung: Je nach Auswahl der Filterparameter kann der Download sehr groß werden (mehrere 100MB)!\n\n\nFormate\nDerzeit wird nur das Datenformat CSV unterstützt, welches problemlos mit Tabellenkalkulations-Tools wie \nMicrosoft Excel, Libre office, R-Studio oder ArcGis verarbeitet werden kann.\nInformationen zu Weiteren Datenformaten finder ihr hier\n\nJede Zeile enthält eine Messung einer senseBox mit dem ausgewählten Phänomen.\nDer Messwert (value), Standort des Sensors (lat, lng, Referenzsystem WGS84) und ein Zeitstempel (createdAt) sind in je einer Spalte angegeben:\n\ncreatedAt;value;lat;lng\n2016-09-20T10:05:49.581Z;18.70;7.64568;51.962372\n2016-09-20T10:00:52.689Z;18.62;7.64568;51.962372\n2016-09-20T09:55:54.282Z;18.47;7.64568;51.962372\n....\n\n\nAPI-Download\nFalls die beiden genannten Möglichkeiten nicht flexibel genug sind, können über die REST API unter /boxes/data auch komplexe Anfragen gestellt werden.\n\nFür solche anfragen bietet sich das Kommandozeilenwerkzeug curl an.\nUnter Linux ein Terminal öffnen und beispielsweise folgenden Befehl eingeben, um sämtliche Temperatur-Messungen im geographischen Bereich 51°N - 52°N, 7°E - 8°E in die Datei measurements.csv herunterzuladen:\n\ncurl \"https://api.opensensemap.org/boxes/data?phenomenon=Temperatur&amp;bbox=7,51,8,52\" &gt; measurements.csv\n\n\nAndere geeignete Parameter (Zeitraum, Box-IDs, …) lassen sich der verlinkten API-Dokumentation entnehmen."
					}
					
				
			
		
			
				
					,
					
					"opensensemap-opensensemap-community": {
						"id": "opensensemap-opensensemap-community",
						"title": "Community Anwendungen",
						"categories": "openSenseMap",
						"url": " /opensensemap/opensensemap-community/",
						"content": "In der Community sind bereits einige Tools und Anwendungen entstanden,\nwelche die openSenseMap integrieren oder als Schnittstelle nutzen.\n\n\n  Falls dir weitere Integrationen bekannt sind, lass es uns wissen!\n\n\nVisualisierung\n\n\n  DevelopmentSeed Dashboard: elegantes Dashboard welches die Messungen einer senseBox anzeigt\n  HPI Makerclub Dashboard (demo)\n  senseBox Dashboard: zeigt aktuelle Messwerte einer senseBox an\n  senseBox Widget\n  Open Sense: Android widget zum Darstellen von aktuellen Messwerten von opensensemap.org (Code auf GitHub)\n\n\n\n\nDatenanalyse\n\n\n  opensensmapr R client: openSenseMap Messwerte und Boxen in der statistischen Umgebung R\n  senseBox openSenseMap R client: An R API for the senseBox project. Download and analyse environmental data provided by https://sensebox.de/en/.\n\n\nSensor Firmware\n\n\n  RasPi Wolkenbedeckungs-Sensor\n  GSM Wassersensor\n  mobile GPS senseBox\n  BigGIS LoRa senseBox\n\n\nSonstige\n\n\n  Alexa senseBox-Skill\n  openhab2 smart home senseBox Integration\n  openSenseMap Game"
					}
					
				
			
		
			
				
					,
					
					"opensensemap-opensensemap-api": {
						"id": "opensensemap-opensensemap-api",
						"title": "API Dokumentation",
						"categories": "openSenseMap",
						"url": " /opensensemap/opensensemap-api/",
						"content": "Die openSenseMap stellt eine API zur Abfrage von Daten zu Boxen und Messungen sowie zum Upload von Messungen unter der Adresse https://api.opensensemap.org/ zur Verfügung.\n\nDie Dokumentation der API-Routen ist hier zu finden."
					}
					
				
			
		
			
				
					,
					
					"sensebox-home-home-solar-erweiterung": {
						"id": "sensebox-home-home-solar-erweiterung",
						"title": "Solar Erweiterung",
						"categories": "senseBox:home",
						"url": " /sensebox:home/home-solar-erweiterung/",
						"content": "Solarzelle\n\n\n\nTechnische Details\n\n  Model-Nummer: VB-010P\n  Maximale Leistung (Pm): 10W\n  Klemmenspannung (V): 7,2V\n  Spannung bei max. Leistung (Vm): 6,0V\n  Kurzschlussströme (Isc): 1,83A\n  Maße: 340x235x17mm\n  Gewicht: 1kg\n\n\nPowerboost\n\nDer Adafruit Powerboost 1000C sorgt durch integrierten Lade-Kreislauf dafür, dass die Solarzelle den Akku auflädt und der Akku seinerseits dann die senseBox betreibt.\n\n\n\nTechnische Details\n\n  Maximale Leistungs-Input: 3,7V\n  Maximaler Leistungs-Output: 5,2V\n  Chipsatz: TI TPS61090\n  2A Interner Schalter\n  LEDs geben Akkuladung an\n  Gewicht: 6g\n\n\nAnschluss\nUm die senseBox mit einer Solarzelle zu benutzen, bedarf es lediglich einem Powerboost und und einem LiPo Akku, etwas um die 1000 mAh sollte genügen. Wie die Komponenten verbunden werden, siehst du im Bild unten. Wir empfehlen eine Brandschutztasche für den Akku, da bei einer Beschädigung hohe Verletzungsgefahr besteht.\n\n\n\n\n  Wichtig \n  Der LiPo-Akku und der Powerboost sollten am besten vor Nässe geschützt aufgebaut werden, wenn ihr die Station draußen betreibt. Das passende Gehäuse gibt es im Set dazu, ist aber auch das Gleiche wie z.B. beim Feinstaubsensor.Beachte, dass niedrige Temperaturen die Leistung des Akkus stark beeinträchtigen kann."
					}
					
				
			
		
			
				
					,
					
					"sensebox-home-home-schritt-3": {
						"id": "sensebox-home-home-schritt-3",
						"title": "senseBox:home Schritt 3",
						"categories": "senseBox:home",
						"url": " /sensebox:home/home-schritt-3/",
						"content": "Um die gemessenen Daten auf die openSenseMap zu übertragen, musst du dich dort zuerst registrieren und eine neue senseBox anlegen. Wie das geht, erfährst du im folgenden Abschnitt.\n\nDie openSenseMap ist ein Projekt um Sensordaten zu speichern, zu vergleichen und zu visualisieren. Schau sie dir doch am besten mal an. Gehe auf www.opensensemap.org und entdecke einen riesigen Pool an Sensordaten aus der ganzen Welt. Nicht nur senseBoxen senden Daten an die openSenseMap, sondern auch andere Microcontroller mit Sensoren. Wie die einzelnen Funktionen der openSenseMap und ihre Schnittstellen funktionieren findest du hier.\n\n1. Nutzeraccount Registrierung\nGehe auf www.opensensemap.org und lege dir einen Account an. Dafür klickst du rechts oben in der Ecke auf “Login” und gehst dann auf “Sign up”. Du brauchst eine gültige E-Mail-Adresse zum Registrieren. Nach erfolgreicher Registrierung erhältst du eine E-Mail mit einem Bestätigungslink. Bitte klicke den Link um die Registrierung abzuschließen.\n\n\n\n2. Eine neue senseBox anlegen\nNach der erfolgreichen Registrierung kannst du damit beginnen deine senseBox anzulegen. Dafür klicke auf “New senseBox / Neue senseBox” in deinem Menü und bestätige die Nutzungsbedingungen. Befolge danach die Anweisungen der Registrierung und gebe folgende Daten an:\n\n\n  Einen frei wählbaren Namen der senseBox\n  Die Umgebung (Exposure), in der du deine senseBox aufstellen möchtest\n  Den Ort (Location), an dem du deine senseBox aufstellen möchtest (du kannst deinen Standort auch automatisch bestimmen lassen)\n\n\nDa die openSenseMap offen für alle Arten von senseBoxen ist, wirst du nach der verwendeten Hardware gefragt. Wähle senseBox:home V2 und den Bee den du verwendest (WiFi, oder Ethernet)\n\n\n\n\n    \n  Du bist dir nicht sicher ob du ein Ethernet oder WiFi-Bee hast, oder kannst den Unterschied zwischen dem Luftdruck und Temperatursensor nicht erkennen? Im Kapitel Komponenten findest du Bilder und weitere Hinweise zu den einzelnen Bauteilen.\n\n\nMöchtest du deine Daten über LoRa an die openSenseMap schicken wählst du bei “Verbindungsart” LoRa aus. Anschließend kannst du im Reiter “Erweitert” deine Lora Einstellungen angeben. Hier musst du die Application-ID und Device-ID angeben, welche du beim TheThingsNetwork angegeben hast. \n\n\nJetzt hast du es fast geschafft! Noch schnell die Sensoren auswählen, welche du an deine senseBox anschließen wirst. Einfach anklicken und fertig. Bei einigen Sensoren musst du noch angeben an welchen Ports auf dem Mikrocontroller diese angeschlossen sind. Danach kannst du den Vorgang abschließen.\n\n3. Summary der Registrierung und Mail erhalten\nWenn du die Registrierung abgeschlossen hast, musst du noch einmal der Veröffentlichung deiner Daten zustimmen. Danach erhälst du eine Summary deiner Registrierung. Dort wird dir deine senseBox ID, deine Sensoren-IDs und der Arduino Code angezeigt.\n\n\n\nDie senseBox ID ist ein eindeutiger Identifikator deiner senseBox. Damit kannst du deine senseBox z.B. über die URL finden (opensensemap.org/explore/HIER-DEINE-SENSEBOX-ID-EINGEBEN) oder in Datensätzen aufspüren. Des Weiteren wird sie für verschiedene Applications und Funktionen rund um die senseBox und die openSenseMap verwendet.\n\nOnline Kompilieren\nDer einfachste Weg deinen Code auf die senseBox zu bekommen ist unseren Online Compiler zu benutzen. Dafür musst du in der Maske einige Angaben machen. Wenn etwas nicht auf deinen individuellen Aufbau der senseBox passt, kannst du das Feld einfach frei lassen. Zum Abschluss drückst du auf “Kompilieren” und eine Datei im Format .bin wird von deinem Browser heruntergeladen. \n\n\nÜbertragen auf die senseBox MCU\n\nSchließt du deine senseBox MCU an deinen Computer an und führst einen Doppelklick auf den roten Button aus wird diese als Wechseldatendräger erkannt. Mit einem Klick auf Code Kompilieren in der Weboberfläche wird dein Programmcode auf dem Server kompiliert und eine .BIN Datei wird dir zum Download angeboten. Je nachdem welches Betriebssystem du verwendest unterscheidet sich nun der Kopiervorgang.\n\nKopieren unter Windows\n\nUnter Windows kannst du die erstellte .BIN Datei einfach per Drag &amp; Drop auf den Wechseldatenträger SENSEBOX kopieren. Die rote LED am Button wird kurz flackern und anschließend startet das Board selbstständig neu und führt deinen Programmcode aus. \n_______\n\nKopieren unter MacOS\n\nUnter MacOS funktioniert das kopieren der .BIN per Drag &amp; Drop leider zurzeit noch nicht. Eine Möglichkeit ist die Datei im Terminal per dd-Befehl zu kopieren (nur erfahrenen Nutzern zu empfehlen!) oder einen alternativen Dateimanager wie zum Beispiel muCommander zu verwenden.\n_______\n\nKopieren unter Linux\n\nUnter Linux kannst du die erstellte .BIN Datei einfach per Drag &amp; Drop auf den Wechseldatenträger SENSEBOX kopieren. Die rote LED am Button wird kurz flackern und anschließend startet das Board selbstständig neu und führt deinen Programmcode aus. \n_______\n\nArduino-Code auf die senseBox laden\nNachdem du den .ino Anhang der Email heruntergeladen hast (oder weiter Unten in der Übersicht kopiert hast), muss dieses Programm auf deine senseBox geladen werden. Dafür musst du natürlich die Arduino IDE (wie in Schritt 1 erklärt) auf deinem Computer heruntergeladen haben. In Kurzfassung kannst du danach folgende Schritte befolgen:\n\nWiFi-Bee\n\n\n  Arduino Anwendung öffnen\n  In der Menüleiste Datei → Öffnen auswählen und die sensebox.ino Datei auswählen\n  Im Dialogfeld wird gefragt, ob die Datei verschoben werden darf. Dieses mit “Ja” oder “Ok” bestätigen.\n  Jetzt musst du dein WiFi-Netzwerk und dein Passwort für das Netzwerk zwischen die \"\" eingeben. Achte darauf, keine Leerzeichen zwischen den \" und den Buchstaben deines Passworts zu haben.\n  Jetzt kannst du as Programm über das Pfeil Icon auf den Mikrocontroller laden.\n  Warten bis das Programm übertragen wurde\n____\n\n\nEthernet-Bee\n\n\n  Arduino Anwendung öffnen\n  In der Menüleiste Datei → Öffnen auswählen und die sensebox.ino Datei auswählen\n  Im Dialogfeld wird gefragt ob die Datei verschoben werden darf. Dieses mit “Ja” oder “Ok” bestätigen.\n  Jetzt kannst du as Programm über das Pfeil Icon auf den Mikrocontroller laden.\n  Warten bis das Programm übertragen wurde\n_______\n\n\nLoRa-Bee\n\n\n  Arduino Anwendung öffnen\n  In der Menüleiste Datei → Öffnen auswählen und die senseBox.ino Datei auswählen\n  Im Dialogfeld wird gefragt ob die Datei verschoben werden darf. Dieses mit “Ja” oder “Ok” bestätigen.\n  Jetzt kannst du as Programm über das Pfeil Icon auf den Mikrocontroller laden.\n  Warten bis das Programm übertragen wurde\n_______\n\n\nWenn alles richtig gelaufen ist, kannst du nun auf der openSenseMap deine Station auswählen und verfolgen, wie Messungen kontinuierlich übertragen werden!\n\n\n    \n  Du kannst dich nicht mehr daran erinnern, wie du den Code von Arduino auf die senseBox überträgst? Schau nochmal in Schritt 1 und Schritt 4 nach, dort wird die Installation und die Übertragung der Tests erklärt. Falls du weitere Fragen hast, nutze unser Forum, um dich zu informieren oder gegebenenfalls einen eigenen Beitrag zu erstellen."
					}
					
				
			
		
			
				
					,
					
					"sensebox-home-home-schritt-2": {
						"id": "sensebox-home-home-schritt-2",
						"title": "senseBox:home Schritt 2",
						"categories": "senseBox:home",
						"url": " /sensebox:home/home-schritt-2/",
						"content": "Programmieren der senseBox MCU mit den verschiedenen Editoren\n\nDu kannst die senseBox MCU mithilfe von drei verschiedenen Editoren Programmieren.\n\nBlockly für senseBox\n\nMit Blockly für senseBox kannst du deine senseBox MCU über eine grafische Programmieroberfläche Programmieren. Auf dem Computer muss keine Software installiert werden und du kannst direkt loslegen. Für Tablets gibt es eine App, sodass auch über ein Tablet drahtlos die senseBox Programmiert werden kann\n\nArduino IDE\n\nDie Arduino IDE kannst du unter kostenlos herunterladen. Die Arduino IDE bietet dir den kompletten Zugriff auf alle Funktionen, die die Programmiersprache Arduino bereithält. Über die Arduino IDE kannst du auch zusätzliche Sensoren und Bauteile, die nicht in Blockly für senseBox oder openRoberta, enthalten sind programmieren. Die Arduino IDE muss auf dem Computer installiert werden und zusätzlich muss ein Board Support Package für die senseBox MCU installiert werden. Wie genau das funktioniert erfährst.\n\nopenRoberta\n\nopenRoberta ist eine weitere Möglichkeit die senseBox zu programmieren. Das openRoberta lab benötigt keine Installation auf deinem Computer und bietet einen ähnlichen Funktionsumfang wie Blockly für senseBox."
					}
					
				
			
		
			
				
					,
					
					"sensebox-home-home-schritt-1": {
						"id": "sensebox-home-home-schritt-1",
						"title": "senseBox:home Schritt 1",
						"categories": "senseBox:home",
						"url": " /sensebox:home/home-schritt-1/",
						"content": "Durch das I2C Stecksystem ist der Anschluss der Sensoren und Komponenten an die senseBox MCU sehr einfach. Hier siehst du noch einmal eine grobe Übersicht über die einzelnen Komponenten.\n\nAnschluss von Bees\n\nDer Anschluss der Bees ist ganz einfach. Durch das Stecksystem reicht es, das Bee direkt auf den Microcontroller aufzusetzen. Dabei gibt es nur zwei Dinge zu beachten:\n\n  Die Ausrichtung auf dem Board\n  Der richtige Portanschluss auf dem Microcontroller.\n\n\nWiFi-Bee, Ethernet-Bee und LoRa-Bee\nDiese Bees werden alle auf den Port 1 aufgesteckt. Den richtigen Port erkennst du an der Beschriftung: XBEE1. Die richtige Richtung beim Aufstecken erkennst du an der 7-eckigen Kennzeichnung auf dem Board und der Bee.\n\n\n\nmSD-Bee\nDie SD-Bee wird an Port 2 aufgesteckt, welcher standardmäßig dafür freigeschalten ist. Den richtigen Port erkennst du an der Beschriftung: XBEE2. Die richtige Richtung beim Aufstecken erkennst du an der 7-eckigen Kennzeichnung auf dem Board und der Bee.\n\n\n\nAnschluss von einfachen Sensoren\nDie Sensoren, welche mit der senseBox gekauft werden können, sind mit den beiliegenden “I2C to I2C” Kabeln sehr einfach anzuschließen. Dafür musst du die Steckplätze auf dem Board verwenden die mit I2C/Wire gekennzeichnet sind.\n\n\n\nAnschluss vom Feinstaubsensor\nDer Feinstaubsensor, der mit der senseBox gekauft werden kann, hat ein beiliegendes passendes Kabel, welches den Sensor mit dem Board verbinden kann. Hierfür musst du die Steckplätze auf dem Board verwenden die mit UART/Serial gekennzeichnet sind. Weitere Infos zum Anschluss des Feinstaubsensors findest du übrigens hier."
					}
					
				
			
		
			
				
					,
					
					"sensebox-home-home-lora": {
						"id": "sensebox-home-home-lora",
						"title": "senseBox:home mit LoRa",
						"categories": "senseBox:home",
						"url": " /sensebox:home/home-LoRa/",
						"content": "Programmieren der senseBox MCU mit den verschiedenen Editoren\n\nDu kannst die senseBox MCU mithilfe von drei verschiedenen Editoren Programmieren.\n\nBlockly für senseBox\n\nMit Blockly für senseBox kannst du deine senseBox MCU über eine grafische Programmieroberfläche Programmieren. Auf dem Computer muss keine Software installiert werden und du kannst direkt loslegen. Für Tablets gibt es eine App, sodass auch über ein Tablet drahtlos die senseBox Programmiert werden kann\n\nArduino IDE\n\nDie Arduino IDE kannst du unter kostenlos herunterladen. Die Arduino IDE bietet dir den kompletten Zugriff auf alle Funktionen, die die Programmiersprache Arduino bereithält. Über die Arduino IDE kannst du auch zusätzliche Sensoren und Bauteile, die nicht in Blockly für senseBox oder openRoberta, enthalten sind programmieren. Die Arduino IDE muss auf dem Computer installiert werden und zusätzlich muss ein Board Support Package für die senseBox MCU installiert werden. Wie genau das funktioniert erfährst.\n\nopenRoberta\n\nopenRoberta ist eine weitere Möglichkeit die senseBox zu programmieren. Das openRoberta lab benötigt keine Installation auf deinem Computer und bietet einen ähnlichen Funktionsumfang wie Blockly für senseBox."
					}
					
				
			
		
			
				
					,
					
					"allgemein-board-support-package-installieren": {
						"id": "allgemein-board-support-package-installieren",
						"title": "Installation des Board Support Package",
						"categories": "Allgemein",
						"url": " /allgemein/board-support-package-installieren/",
						"content": "Schritt 2: Board-Support-Package installieren\n\nDamit die Arduino IDE deine senseBox MCU unterstützt und du Programme auf diese übertragen kannst, musst du vor Beginn noch zwei Board-Support-Packages installieren. Diese beinhalten die nötigen Treiber und die notwendige Software, um mit deinem Prozessor zu kommunizieren. Das Board-Support-Package der senseBox enthält außerdem bereits unsere senseBox-Libraries. Damit stehen euch alle grundlegenden Methoden zur Programmierung der beiliegenden Sensoren zur Verfügung.\n\n    \n    \n\n\nLibraries\n\nFür die Programmierung der senseBox sollten zu Beginn unbedingt die senseBox-Libraries eingebunden werden. Diese Libraries haben wir für euch in das Board-Support-Package der senseBox integriert, um euch die Installation möglichst einfach zu gestalten.\n\nEine Library ist wie der Name schon sagt eine Sammlung von etwas - eine Sammlung von Methoden um genauer zu sein. Methoden sind in der Programmierung kleinere Abschnitte von Code, die auf ein Objekt angewendet werden können. \nBei der senseBox zum Beispiel kann eine Methode aufgerufen werden, um die LEDs auf dem MCU ein- und auszuschalten. Es gibt eine Menge solcher Standardmethoden, die von einer Vielzahl an Programmmen benutzt werden. Um diese Methoden nicht alle einzeln in den Programmcode übertragen zu müssen, können sie in Libraries abgelegt werden. \nEine Library ist also eine Datei, in der viele Methoden gespeichert werden. Man kann Libraries in seinen Code einbinden. Dafür reicht es, wenn sie im Arduino-Ordner für Libraries gespeichert sind und man sie dann mit einer einzigen Zeile zu Beginn des Programmcodes einbindet. Das sieht in Arduino für die Library mit dem Namen “senseBoxIO” wie folgt aus:\n\n#include &lt;senseBoxMCU.h&gt;;\n\n\nIst die Library eingebunden, können alle in ihr enthaltenen Methoden im Code benutzt werden.\n\nAnleitung für Windows\nFüge die folgende URL in deiner Arduino IDE unter Datei -&gt; Voreinstellungen in das Feld für Zusätzliche Bordverwalter-URLs ein:\nhttps://github.com/sensebox/senseBoxMCU-core/raw/master/package_sensebox_index.json\n\n\n\n\nÖffne dann den Boardverwalter unter Werkzeuge -&gt; Board:”…” -&gt; Boardverwalter und installiere dort die zwei Board-Support-Packages mit den Namen Arduino SAMD Boards by Arduino und senseBox SAMD Boards by senseBox.\n\n\n\n\n    \n  Gib \"SAMD\" oben in die Suchleiste ein um die Packages schneller zu finden\n\n\nDa wir das senseBox SAMD Boards-Package für euch regelmäßig aktualisieren, solltet ihr immer mal wieder in den Boardverwalter gehen und nachschauen, ob das senseBox SAMD Boards-Package noch aktuell ist. Öffnet dafür, wie oben beschrieben, den Boardverwalter und sucht nach senseBox SAMD Boards. Wenn ihr auf den Eintrag in der Liste klickt, erscheint dort, im Falle einer neuen Version, ein Update-Button. Klickt diesen, um die neuste Version zu installieren.\n\n\n\n\n    \n  Wichtig ist, zuerst auf den Eintrag zu klicken. Ansonsten wird der Update-Button nicht angezeigt, auch wenn es bereits eine neue Version gibt.\n\n\nAnleitung für Mac\nFüge die folgende URL in deiner Arduino IDE unter Arduino -&gt; Einstellungen... in das Feld für Zusätzliche Bordverwalter-URLs ein:\nhttps://github.com/sensebox/senseBoxMCU-core/raw/master/package_sensebox_index.json\n\n\n\n\nÖffne dann den Boardverwalter unter Werkzeuge -&gt; Board:”…” -&gt; Boardverwalter und installiere dort die zwei Board-Support-Packages mit den Namen Arduino SAMD Boards by Arduino und senseBox SAMD Boards by senseBox.\n\n\n\n\n\n\n    \n  Gib \"SAMD\" oben in die Suchleiste ein um die Packages schneller zu finden\n\n\nDa wir das senseBox SAMD Boards-Package für euch regelmäßig aktualisieren, solltet ihr immer mal wieder in den Boardverwalter gehen und nachschauen, ob das senseBox SAMD Boards-Package noch aktuell ist. Öffnet dafür, wie oben beschrieben, den Boardverwalter und sucht nach senseBox SAMD Boards. Wenn ihr auf den Eintrag in der Liste klickt, erscheint dort, im Falle einer neuen Version, ein Update-Button. Klickt diesen, um die neuste Version zu installieren.\n\n\n\n\n    \n  Wichtig ist, zuerst auf den Eintrag zu klicken. Ansonsten wird der Update-Button nicht angezeigt, auch wenn es bereits eine neue Version gibt.\n\n\nAnleitung für Linux\nFüge die folgende URL in deiner Arduino IDE unter Datei -&gt; Voreinstellungen in das Feld für Zusätzliche Bordverwalter-URLs ein:\nhttps://github.com/sensebox/senseBoxMCU-core/raw/master/package_sensebox_index.json\n\n\n\n\nÖffne dann den Boardverwalter unter Werkzeuge -&gt; Board:”…” -&gt; Boardverwalter und installiere dort die zwei Board-Support-Packages mit den Namen Arduino SAMD Boards by Arduino und senseBox SAMD Boards by senseBox.\n\n\n\n\n    \n  Gib \"SAMD\" oben in die Suchleiste ein um die Packages schneller zu finden\n\n\nDa wir das senseBox SAMD Boards-Package für euch regelmäßig aktualisieren, solltet ihr immer mal wieder in den Boardverwalter gehen und nachschauen, ob das senseBox SAMD Boards-Package noch aktuell ist. Öffnet dafür, wie oben beschrieben, den Boardverwalter und sucht nach senseBox SAMD Boards. Wenn ihr auf den Eintrag in der Liste klickt, erscheint dort, im Falle einer neuen Version, ein Update-Button. Klickt diesen, um die neuste Version zu installieren.\n\n\n\n\n    \n  Wichtig ist, zuerst auf den Eintrag zu klicken. Ansonsten wird der Update-Button nicht angezeigt, auch wenn es bereits eine neue Version gibt."
					}
					
				
			
		
			
				
					,
					
					"bees-bee-wifi": {
						"id": "bees-bee-wifi",
						"title": "WiFi-Bee",
						"categories": "Bees",
						"url": " /bees/bee-wifi/",
						"content": "Verbindungsstück um die senseBox mit dem Internet zu verbinden. Die Daten der senseBox werden per WLAN (WiFi) in das bestehende Netzwerk übertragen. Das WiFi-Bee basiert auf dem ATWINC1500 Mikrochip von Atmel, welcher einen sehr geringen Energieverbrauch und eine hohe Reichweite hat.\n\nBei einigen unserer WiFi Bees vom Typ WINC1500 kann es vorkommen, dass eine veraltete Firmware (Version 19.4.4) installiert ist. Das kann zu Übertragungsproblemen führen. Sollten diese Probleme bei dir auftreten, schaue dir !!!! an, um die Firmware zu aktualisieren.\n\n\n\nTechnische Informationen\n\n\n  “Plug-in-and-Go” senseBox kompatibel\n  Single-band 2.4GHz b/g/n\n  Betriebsspannung: 3.0V to 4.2V\n  Verschlüsselungsprotokolle: WPA/WPA2 Personal, TLS, SSL\n  Netzwerkdienste: DHCP, DNS, TCP/IP (IPv4), UDP, HTTP, HTTPS\n  Bezeichnung: WINC1500\n  Maße: 24mm x 25mm x 9mm\n  Gewicht: 3,5 g\n\n\nVerbindungstest\n\nUm die Verbindung des Bees mit dem Internet zu testen, also quasi die Funktion sowohl der Komponente, als auch des Netzwerks zu prüfen, nutze den folgenden Sketch:\n\n#include &lt;SPI.h&gt;\n#include &lt;WiFi101.h&gt;\n#include &lt;senseBoxIO.h&gt;\n\nvoid setup()\n{\n    // Initialisiert den seriellen Monitor\n    Serial.begin(9600);\n\n    // Starte WINC1500 (WiFi-Bee) in XBEE1 Socket neu\n    senseBoxIO.powerXB1(false);\n    delay(250);\n    senseBoxIO.powerXB1(true);\n}\n\nvoid loop()\n{\n    delay(5000);\n    // Gibt installierte und aktuellste Firmware Version aus\n    String fv = WiFi.firmwareVersion();\n    Serial.print(\"Firmware installed: \");\n    Serial.println(fv);\n    Serial.print(\"Latest firmware: \");\n    Serial.println(WIFI_FIRMWARE_LATEST_MODEL_B);\n\n    // Gibt IP-Adresse der senseBox aus\n    IPAddress ip = WiFi.localIP();\n    Serial.print(\"IP: \");\n    Serial.println(ip);\n    delay(5000);\n}\n\n\nWenn bei allen Ausgaben im seriellen Monitor Werte angezeigt werden, insbesondere die IP-Adresse in etwa in der Form 192.107.256.4 ausgegeben wird, ist das WiFi-Bee richtig initialisiert und die senseBox kann mit dem Internet genutzt werden."
					}
					
				
			
		
			
				
					,
					
					"bees-bee-sd": {
						"id": "bees-bee-sd",
						"title": "SD-Bee",
						"categories": "Bees",
						"url": " /bees/bee-sd/",
						"content": "Mit dem mSD-Bee können die Daten der senseBox auf einer SD-Karte gespeichert werden. So kann man messen, auch wenn keine Internetanschluss in der Nähe der senseBox ist.\n\n\n\nTechnische Informationen\n\n  “Plug-in-and-Go” senseBox kompatibel\n  Port für miniSD-Karte\n  Bezeichnung: mSD-Bee\n  Maße: 24mm x 21mm x 9mm\n  Gewicht: 2,4 g\n\n\nAchte darauf, dass die mSD-Bee an den XBEE2-Stecker der senseBox-MCU angeschlossen werden muss, anonsten kann es zu Problemen beim Speichern deiner Messwerte kommen.\n\nProgrammierung (Arduino)\nIm folgenden Beispiel zeigen wir dir, wie du deine Daten auf einer SD-Karte speichern kannst.\n\n// Einladen der Bibliotheken\n#include &lt;SPI.h&gt;\n#include &lt;SD.h&gt;\n#include \"SenseBoxMCU.h\"\n\nHDC1080 hdc;\nFile myFile;\n// Name der Datei auf der SD-Karte\n// Achte darauf, dass dieser Name (ohne Dateiendung) nicht länger als 8 Buchstaben lang sein darf! \nString fileName = \"SenseBox.txt\";\n\nvoid setup()\n{ \n    // Starten der SD-Bee\n    SD.begin(28);\n    // Öffnen der Datei auf der SD-Karte\n    myFile = SD.open(fileName, FILE_WRITE);\n    myFile.close();\n\n    hdc.begin();\n};\n\nvoid loop()\n{\n    // Datei öffnen mit Schreibzugriff\n    myFile = SD.open(fileName, FILE_WRITE);\n    myFile.println(hdc.getTemperature());\n    // Nach Benutzung wird die Datei wieder geschlossen\n    myFile.close();\n};"
					}
					
				
			
		
			
				
					,
					
					"bees-bee-lora": {
						"id": "bees-bee-lora",
						"title": "LoRa-Bee",
						"categories": "Bees",
						"url": " /bees/bee-lora/",
						"content": "Verwendet die LoRa-Schnittstelle um Daten stromsparend und kostenlos ins Internet zu übertragen. Das Besondere an der Übertragunstechnologie ist ihre Reichweite, so muss ein LoRa-Gateway im Umkreis von lediglich 2 bis hin zu 40 Kilometern bestehen, je nachdem ob die Station im städtischen Gebiet oder im ländlichen Raum ohne Gebirge (ggf. über Wasser) genutzt werden soll.\nDas von senseBox entwickelte LoRaWan™-XBee-Modul überträgt Daten mithilfe der LoRa-Funk-Standards des TheThingsNetwork. Die hierzu benötigte Infrastruktur wird von der TTN-Community bereit gestellt, und ist in immer mehr Regionen verfügbar. Deutschland besitzt im internationalen Vegleich schon eine sehr gute Abdeckung mit ~2000 Gateways.\n\n\n\nTechnische Informationen\n\n  HopeRF RFM95W/RFM96W LoRa Transceiver\n  LoRa-Bee 868 / 915 MHz nutzt RFM95W (SX1276 kompatibel)\n  LoRa-Bee 433 / 470 MHz nutzt RFM96W (SX1276 kompatibel)\n  SPI interface\n  Bezeichnung: RFN9xW\n  Maße: 46mm x 25mm x 12mm\n  Gewicht: 1,1 g\n\n\nHinweise\nBitte prüfe, bevor du dir eine senseBox mit LoRa Bee holst, ob dein Gebiet bereits von LoRa erschlossen ist.\nDies ist auf der Karte des TTN möglich.\n\nUpload über LoRaWAN\nEs ist möglich Sensordaten per LoRaWAN™ durch das TheThingsNetwork\n(TTN) auf die openSenseMap zu laden.\nLoRa ist ein zunehmend Verbreitung findender Funkstandard, welcher ähnlich wie\nWiFi digitale Datenübertragung in einem IP-Netzwerk erlaubt, jedoch deutlich\nandere Features bietet:\n\n\n  Datendurchsatz: 300 - 3000 Bit/s\n  Reichweite:     ~ 15km (Im Durchschnitt)\n\n\nTTN ist eins von mehreren Projekten, welches die zur Funk-Hardware zugehörige\nInfrastruktur für das IP-Netzwerk implementiert, wodurch registrierte Geräte\nmit dem Internet verbunden werden können.\n\nNutzer können Gateways sowie Nodes zu dem Netzwerk hinzufügen.\n\nTheThingsNetwork &amp; openSenseMap Integration\nDie openSenseMap bietet eine direkte Integration in das TheThingsNetwork, was die\nKonfiguration stark vereinfacht. Das TheThingsNetwork ist ein LoRa Netzwerk, welches dafür zuständig ist Daten von deiner senseBox an die openSenseMap weiterzuleiten. Erstelle als ersten Schritt dieses Tutorials einen Account auf der Website.\n\nRegistrierung im TheThingsNetwork\nHast du einen Account erstellt, musst du nun eine Application hinzufügen.Dies kannst du über diesen Link erledigen. Hier musst du eine Application ID, also einen Namen für deine Anwendung eingeben.Nachdem die Application hinzugefügt wurde, musst du nun ein Device hinzufügen. Dies geschieht über den Reiter Devices-&gt;Register device. Auch hier musst du eine ID für das Gerät hinzufügen. Die Device-EUI kannst du dir mit einem Klick auf das Symbol generieren lassen.Zu guter Letzt musst du dem TTN-Netzwerk nun noch mitteilen, dass deine Daten an die openSenseMap weitergeleitet werden sollen. Hierfür gehst du auf deine Übersicht, wählst deine eben erstellte Application aus und gehst auf den Reiter Integrations. Dort findest du den Knopf Add integration, woraufhin sich ein Fenster mit einer Reihe an Auswahlmöglichkeiten öffnet. Unter diesen Möglichkeiten wählst du HTTP Integration aus. Die Process ID kannst du wieder selbst wählen. Bei URL gibst du https://ttn.opensensemap.org/v1.1 an und die Methode lautet POST. Unter Access Key den default key auswählen. Das Authorization Feld kann leer bleiben!\n\n\n\nRegistrierung auf der openSenseMap\nFür die Datenübertragung zur openSenseMap müssen die app_id und dev_id bei\nder Registrierung auf der openSenseMap in der TTN-Konfiguration angegeben\nwerden. Darüber hinaus muss ein passendes Decoding-Profil konfiguriert werden,\nwelches bestimmt wie die - wegen der geringen Bandbreite als rohe Bytes \nübertragenen - Daten als Messungen interpretiert werden sollen.\n\n\n\nOptional kann im Feld port noch der Port angegeben werden, auf welchem\nder Sender seine Daten an das TTN schickt. So lassen sich die selbe app_id\nund dev_id für mehrere Sensorstationen verwenden.\n\nArduino Sketch\nSo könnte ein Arduino Sketch aussehen, mit dem du Daten über das TTN-Netzwerk an die openSenseMap senden kannst. Mit diesem Sketch werden die Phänomene:Lufttemperatur, Luftfeuchte, PM10, PM2.5, UV-Intensität, Beleuchtungsstärke und Luftdruck gemessen.\n\n\n     \n    Wichtig: Du musst deine eben erstellte Application-EUI, Device-EUI und den App-Key in den Sketch einfügen. Dies machst du in den ersten Zeilen des Programmcode wo 'INSERT YOUR ID HERE' steht.  Achte darauf, dass auf der TTN-Homepage du für die Device-EUI und die Application-EUI das lsb-Format und für den App-Key das msb-Format ausgewählt hast!\n\n\n\n\n/*\n\n  senseBox:home - Citizen Sensingplatform\n\n  Version: lorav2.0.0\n\n  Date: 2018-09-11\n\n  Homepage: https://www.sensebox.de https://www.opensensemap.org\n\n  Author: Reedu GmbH &amp; Co. KG\n\n  Note: Sketch for senseBox:home LoRa MCU Edition\n\n  Model: homeV2lora\n\n  Email: support@sensebox.de\n\n  Code is in the public domain.\n\n  https://github.com/sensebox/node-sketch-templater\n\n*/\n\n#include &lt;LoraMessage.h&gt;\n\n#include &lt;lmic.h&gt;\n\n#include &lt;hal/hal.h&gt;\n\n#include &lt;SPI.h&gt;\n\n#include &lt;senseBoxIO.h&gt;\n\n#include &lt;Adafruit_Sensor.h&gt;\n\n#include &lt;Adafruit_HDC1000.h&gt;\n\n#include &lt;Adafruit_BMP280.h&gt;\n\n#include &lt;Makerblog_TSL45315.h&gt;\n\n#include &lt;VEML6070.h&gt;\n\n#include &lt;SDS011-select-serial.h&gt;\n\n// Uncomment the next line to get debugging messages printed on the Serial port\n\n// Do not leave this enabled for long time use\n\n#define ENABLE_DEBUG\n\n#ifdef ENABLE_DEBUG\n\n#define DEBUG(str) Serial.println(str)\n\n#else\n\n#define DEBUG(str)\n\n#endif\n\n// Connected sensors\n\n// Temperatur\n\n#define HDC1080_CONNECTED\n\n// rel. Luftfeuchte\n\n#define HDC1080_CONNECTED\n\n// Luftdruck\n\n#define BMP280_CONNECTED\n\n// Beleuchtungsstärke\n\n#define TSL45315_CONNECTED\n\n// UV-Intensität\n\n#define VEML6070_CONNECTED\n\n// PM10\n\n#define SDS011_CONNECTED\n\n// Number of serial port the SDS011 is connected to. Either Serial1 or Serial2\n\n#ifdef SDS011_CONNECTED\n\n#define SDS_UART_PORT (Serial1)\n\n#endif\n\n//Load sensors / instances\n\n#ifdef HDC1080_CONNECTED\n\n  Adafruit_HDC1000 HDC = Adafruit_HDC1000();\n\n  float temperature = 0;\n\n  float humidity = 0;\n\n#endif\n\n#ifdef BMP280_CONNECTED\n\n  Adafruit_BMP280 BMP;\n\n  double pressure;\n\n#endif\n\n#ifdef TSL45315_CONNECTED\n\n  uint32_t lux;\n\n  Makerblog_TSL45315 TSL = Makerblog_TSL45315(TSL45315_TIME_M4);\n\n#endif\n\n#ifdef VEML6070_CONNECTED\n\n  VEML6070 VEML;\n\n  uint16_t uv;\n\n#endif\n\n#ifdef SDS011_CONNECTED\n\n  SDS011 SDS(SDS_UART_PORT);\n\n  float pm10 = 0;\n\n  float pm25 = 0;\n\n#endif\n\n\n\nNun müssen wir im Sketch die eben erstellten Device und Application EUI’s sowie den App Key eingeben\n\n// This EUI must be in little-endian format, so least-significant-byte\n\n// first. When copying an EUI from ttnctl output, this means to reverse\n\n// the bytes. For TTN issued EUIs the last bytes should be 0xD5, 0xB3,\n\n// 0x70.\n\n\nstatic const u1_t PROGMEM APPEUI[8]= {DIE APPLICATION EUI HIER(lsb-Format)};\n\nvoid os_getArtEui (u1_t* buf) { memcpy_P(buf, APPEUI, 8);}\n\n// This should also be in little endian format, see above.\n\nstatic const u1_t PROGMEM DEVEUI[8]={DIE DEVICE EUI HIER(lsb-Format)};\n\nvoid os_getDevEui (u1_t* buf) { memcpy_P(buf, DEVEUI, 8);}\n\n// This key should be in big endian format (or, since it is not really a\n\n// number but a block of memory, endianness does not really apply). In\n\n// practice, a key taken from ttnctl can be copied as-is.\n\n// The key shown here is the semtech default key.\n\nstatic const u1_t PROGMEM APPKEY[16] ={DER APP KEY HIER(msb-Format)};\n\nvoid os_getDevKey (u1_t* buf) {  memcpy_P(buf, APPKEY, 16);}\n\n\nNachfolgend geben wir ein Interval an in welchen die Daten an das TTN-Netzwerk geschickt werden sollen. In diesem Sketch beträgt das Intervall alle 60 Sekunden.  Des weiteren werden die Pins gemappt und eine onEvent()-Funktion zum Debuggen im Seriellen Monitor wird erstellt.\n\n\nstatic osjob_t sendjob;\n\n// Schedule TX every this DemaJetny seconds (might become longer due to duty\n\n// cycle limitations).\n\nconst unsigned TX_INTERVAL = 60;\n\n// Pin mapping\n\nconst lmic_pinmap lmic_pins = {\n\n  .nss = PIN_XB1_CS,\n\n  .rxtx = LMIC_UNUSED_PIN,\n\n  .rst = LMIC_UNUSED_PIN,\n\n  .dio = {PIN_XB1_INT, PIN_XB1_INT, LMIC_UNUSED_PIN},\n\n};\n\nvoid onEvent (ev_t ev) {\n\n  senseBoxIO.statusGreen();\n\n  DEBUG(os_getTime());\n\n  switch(ev) {\n\n    case EV_SCAN_TIMEOUT:\n\n      DEBUG(F(\"EV_SCAN_TIMEOUT\"));\n\n      break;\n\n    case EV_BEACON_FOUND:\n\n      DEBUG(F(\"EV_BEACON_FOUND\"));\n\n      break;\n\n    case EV_BEACON_MISSED:\n\n      DEBUG(F(\"EV_BEACON_MISSED\"));\n\n      break;\n\n    case EV_BEACON_TRACKED:\n\n      DEBUG(F(\"EV_BEACON_TRACKED\"));\n\n      break;\n\n    case EV_JOINING:\n\n      DEBUG(F(\"EV_JOINING\"));\n\n      break;\n\n    case EV_JOINED:\n\n      DEBUG(F(\"EV_JOINED\"));\n\n      // Disable link check validation (automatically enabled\n\n      // during join, but not supported by TTN at this time).\n\n      LMIC_setLinkCheckMode(0);\n\n      break;\n\n    case EV_RFU1:\n\n      DEBUG(F(\"EV_RFU1\"));\n\n      break;\n\n    case EV_JOIN_FAILED:\n\n      DEBUG(F(\"EV_JOIN_FAILED\"));\n\n      break;\n\n    case EV_REJOIN_FAILED:\n\n      DEBUG(F(\"EV_REJOIN_FAILED\"));\n\n      break;\n\n    case EV_TXCOMPLETE:\n\n      DEBUG(F(\"EV_TXCOMPLETE (includes waiting for RX windows)\"));\n\n      if (LMIC.txrxFlags &amp; TXRX_ACK)\n\n        DEBUG(F(\"Received ack\"));\n\n      if (LMIC.dataLen) {\n\n        DEBUG(F(\"Received \"));\n\n        DEBUG(LMIC.dataLen);\n\n        DEBUG(F(\" bytes of payload\"));\n\n      }\n\n      // Schedule next transmission\n\n      os_setTimedCallback(&amp;sendjob, os_getTime()+sec2osticks(TX_INTERVAL), do_send);\n\n      break;\n\n    case EV_LOST_TSYNC:\n\n      DEBUG(F(\"EV_LOST_TSYNC\"));\n\n      break;\n\n    case EV_RESET:\n\n      DEBUG(F(\"EV_RESET\"));\n\n      break;\n\n    case EV_RXCOMPLETE:\n\n      // data received in ping slot\n\n      DEBUG(F(\"EV_RXCOMPLETE\"));\n\n      break;\n\n    case EV_LINK_DEAD:\n\n      DEBUG(F(\"EV_LINK_DEAD\"));\n\n      break;\n\n    case EV_LINK_ALIVE:\n\n      DEBUG(F(\"EV_LINK_ALIVE\"));\n\n      break;\n\n    default:\n\n      DEBUG(F(\"Unknown event\"));\n\n      break;\n\n  }\n\n}\n\n\n\nAls nächstes definieren wir das LoRa Paket was an das TTN-Netzwerk übermittelt wird. Mit LoRaMessage message deklarieren wir das Paket message welchen sukzessiv die Messwerte unserer Sensoren hinzugefügt wird.\n\n\n\nvoid do_send(osjob_t* j){\n\n  // Check if there is not a current TX/RX job running\n\n  if (LMIC.opmode &amp; OP_TXRXPEND) {\n\n    DEBUG(F(\"OP_TXRXPEND, not sending\"));\n\n  } else {\n\n    LoraMessage message;\n\n    //-----Temperature-----//\n\n    //-----Humidity-----//\n\n    #ifdef HDC1080_CONNECTED\n\n      DEBUG(F(\"Temperature: \"));\n\n      temperature = HDC.readTemperature();\n\n      DEBUG(temperature);\n\n      message.addUint16((temperature + 18) * 771);\n\n      delay(2000);\n\n  \n\n      DEBUG(F(\"Humidity: \"));\n\n      humidity = HDC.readHumidity();\n\n      DEBUG(humidity);\n\n      message.addHumidity(humidity);\n\n      delay(2000);\n\n    #endif\n\n    //-----Pressure-----//\n\n    #ifdef BMP280_CONNECTED\n\n      float altitude;\n\n      pressure = BMP.readPressure()/100;\n\n      altitude = BMP.readAltitude(1013.25); //1013.25 = sea level pressure\n\n      DEBUG(F(\"Pressure: \"));\n\n      DEBUG(pressure);\n\n      message.addUint16((pressure - 300) * 81.9187);\n\n      delay(2000);\n\n    #endif\n\n    //-----Lux-----//\n\n    #ifdef TSL45315_CONNECTED\n\n      DEBUG(F(\"Illuminance: \"));\n\n      lux = TSL.readLux();\n\n      DEBUG(lux);\n\n      message.addUint8(lux % 255);\n\n      message.addUint16(lux / 255);\n\n      delay(2000);\n\n    #endif\n\n    //-----UV intensity-----//\n\n    #ifdef VEML6070_CONNECTED\n\n      DEBUG(F(\"UV: \"));\n\n      uv = VEML.getUV();\n\n      DEBUG(uv);\n\n      message.addUint8(uv % 255);\n\n      message.addUint16(uv / 255);\n\n      delay(2000);\n\n    #endif\n\n    //-----PM-----//\n\n    #ifdef SDS011_CONNECTED\n\n      uint8_t attempt = 0;\n\n      while (attempt &lt; 5) {\n\n        bool error = SDS.read(&amp;pm25, &amp;pm10);\n\n        if (!error) {\n\n          DEBUG(F(\"PM10: \"));\n\n          DEBUG(pm10);\n\n          message.addUint16(pm10 * 10);\n\n          DEBUG(F(\"PM2.5: \"));\n\n          DEBUG(pm25);\n\n          message.addUint16(pm25 * 10);\n\n          break;\n\n        }\n\n        attempt++;\n\n      }\n\n    #endif\n    \n\n    // Prepare upstream data transmission at the next possible time.\n\n    LMIC_setTxData2(1, message.getBytes(), message.getLength(), 0);\n\n    DEBUG(F(\"Packet queued\"));\n\n  }\n\n  // Next TX is scheduled after TX_COMPLETE event.\n\n}\n\n\n\nAnschließend folgt die setup()-Funktion die du es aus den bisherigen Arduino-Sketches bereits kennen solltest. In dieser starten wir unsere Sensoren und den seriellen Monitor.\n\n\nvoid setup() {\n\n  #ifdef ENABLE_DEBUG\n\n    Serial.begin(9600);\n\n  #endif\n\n  delay(3000);\n\n  // RFM9X (LoRa-Bee) in XBEE1 Socket\n\n  senseBoxIO.powerXB1(false); // power off to reset RFM9X\n\n  delay(250);\n\n  senseBoxIO.powerXB1(true);  // power on\n\n  \n\n  // Sensor initialization\n\n  DEBUG(F(\"Initializing sensors...\"));\n\n  #ifdef VEML6070_CONNECTED\n\n    VEML.begin();\n\n    delay(500);\n\n  #endif\n\n  #ifdef HDC1080_CONNECTED\n\n    HDC.begin();\n\n  #endif\n\n  #ifdef BMP280_CONNECTED\n\n    BMP.begin(0x76);\n\n  #endif\n\n  #ifdef TSL45315_CONNECTED\n\n    TSL.begin();\n\n  #endif\n\n  #ifdef SDS011_CONNECTED\n\n    SDS_UART_PORT.begin(9600);\n\n  #endif\n \n\n  DEBUG(F(\"Sensor initializing done!\"));\n\n  DEBUG(F(\"Starting loop in 3 seconds.\"));\n\n  delay(3000);  \n\n  // LMIC init\n\n  os_init();\n\n  // Reset the MAC state. Session and pending data transfers will be discarded.\n\n  LMIC_reset();\n\n  // Start job (sending automatically starts OTAA too)\n\n  do_send(&amp;sendjob);\n\n}\n\n\n\nZu guter letzt fehlt jetzt noch die loop()-Funktion. In dieser wird deklariert, dass der in den globalen Variablen deffinierte os_loop() ausgeführt wird.\n\n\nvoid loop() {\n\n  os_runloop_once();\n\n}\n\n\nDecoding Profile\nDas Decoding wird nun von der openSenseMap durchgeführt. Es ist also keine manuelle Einrichtung eines Decoders nötig. Achte nur darauf, dass du bei der Registration deiner senseBox auf der openSenseMap die Datenübertragung per LoRa angibst !"
					}
					
				
			
		
			
				
					,
					
					"bees-bee-lan": {
						"id": "bees-bee-lan",
						"title": "Ethernet-Bee",
						"categories": "Bees",
						"url": " /bees/bee-lan/",
						"content": "Verbindungsstück um die senseBox mit dem Internet zu verkabeln. Die Daten der senseBox werden per per LAN-Kabel an direkt an einen Router übertragen. Das LAN-Bee basiert auf dem W5500 Mikrochip von Wiznet, welcher einen hohe Ethernet Datenübertragungsrate ermöglicht.&lt;/div&gt;\n\n\n\nTechnische Informationen\n\n\n  “Plug-in-and-Go” senseBox kompatibel\n  3.3V Betriebsspannung mit 5V I/O Signal Toleranz\n  Bezeichnung: W5500\n  Maße: 46mm x 25mm x 12mm\n  Gewicht: 9,2 g\n\n\nProgrammierung\n\n#include &lt;SPI.h&gt;\n#include &lt;Ethernet.h&gt;\n#include &lt;senseBoxIO.h&gt;\n\nvoid setup()\n{\n    // Initialisiert den seriellen Monitor\n    Serial.begin(9600);\n    // Startet W5500 (LAN-Bee) in XBEE1 Socket neu\n    senseBoxIO.powerXB1(false);\n    delay(250);\n    senseBoxIO.powerXB1(true);\n    Ethernet.init(PIN_XB1_CS);\n}\n\nvoid loop()\n{\n    // Gibt IP-Adresse der senseBox aus\n    ip = Ethernet.localIP();\n    Serial.print(\"IP: \");\n    Serial.println(ip);\n    delay(5000);\n}\n\n\nHinweise und Tipps\n\nDas LAN-Bee wird ohne LAN-Kabel geliefert. Es eignen sich aber insbesondere flache LAN-Kabel, welche man einfach durch Fenster und Türen nach außen legen kann. Insbesondere in Kombination mit Power over Ethernet (PoE) kann die senseBox dann einfach betrieben werden."
					}
					
				
			
		
			
				
					,
					
					"allgemein-allgemein-senseboxio-library": {
						"id": "allgemein-allgemein-senseboxio-library",
						"title": "senseBoxIO Library",
						"categories": "Allgemein",
						"url": " /allgemein/allgemein-senseboxio-library/",
						"content": "Die senseBoxIO Library ist Bestandteil des Board-Support-Package und wird automatisch installiert.\n\nDie senseBoxIO Library lässt sich einzeln über folgenden Befehl einbinden:\n\ninclude &lt;senseBoxIO.h&gt;\n\n\n\n  Beachte: Verwendest du bereits die senseBoxMCU Library ist die senseBoxIO Library bereits integriert und muss nicht zustäzlich inkludiert werden\n\n\nEin-/ausschalten der Ports\n\nÜber die senseBoxIO Library können nicht verwendete Ports Ein-/ausgeschaltet werden:\n\nDeaktivieren aller Ports\n void powerNone(void)\n\nAktivieren aller Ports\n\n  void powerAll(void)\n\nSelektives Ein-/Ausschalten von Ports und Anschlüssen\n\n\n  void powerI2C(bool on) //power the I2C Ports\n  \n  void powerUART(bool on) //power the UART Ports\n\n  void powerXB1(bool on) //power XBEE Port 1\n \n  void powerXB2(bool on) //power XBEE Port 2\n \n  void SPIselectNone(void) //\n \n  void SPIselectXB1(void) //\n \n  void SPIselectXB2(void) //\n\n\n\nEin-/Ausschalten der Status LED\n\nErlaubt das Ein-/Ausschalten der Status LED’s\n\n  void statusNone(void) // deaktiviere alle Status LED's\n\n  void statusRed(void) //aktiviere die rote Status LED\n\n  void statusGreen(void) //aktivere die grüne Status LED"
					}
					
				
			
		
			
				
					,
					
					"allgemein-allgemein-sensebox-editoren": {
						"id": "allgemein-allgemein-sensebox-editoren",
						"title": "Editoren für die senseBox",
						"categories": "Allgemein",
						"url": " /allgemein/allgemein-sensebox-editoren/",
						"content": "Programmieren der senseBox MCU mit den verschiedenen Editoren\n\nDu kannst die senseBox MCU mithilfe von drei verschiedenen Editoren Programmieren.\n\nBlockly für senseBox\n\nMit Blockly für senseBox kannst du deine senseBox MCU über eine grafische Programmieroberfläche Programmieren. Auf dem Computer muss keine Software installiert werden und du kannst direkt loslegen. Für Tablets gibt es eine App, sodass auch über ein Tablet drahtlos die senseBox Programmiert werden kann\n\n\n\nArduino IDE\n\nDie Arduino IDE kannst du unter kostenlos herunterladen. Die Arduino IDE bietet dir den kompletten Zugriff auf alle Funktionen, die die Programmiersprache Arduino bereithält. Über die Arduino IDE kannst du auch zusätzliche Sensoren und Bauteile, die nicht in Blockly für senseBox oder openRoberta, enthalten sind programmieren. Die Arduino IDE muss auf dem Computer installiert werden und zusätzlich muss ein Board Support Package für die senseBox MCU installiert werden. Wie genau das funktioniert erfährst.\n\n\n\nopenRoberta\n\nopenRoberta ist eine weitere Möglichkeit die senseBox zu programmieren. Das openRoberta lab benötigt keine Installation auf deinem Computer und bietet einen ähnlichen Funktionsumfang wie Blockly für senseBox."
					}
					
				
			
		
			
				
					,
					
					"allgemein-allgemein-mcu-library": {
						"id": "allgemein-allgemein-mcu-library",
						"title": "senseBoxMCU Library",
						"categories": "Allgemein",
						"url": " /allgemein/allgemein-mcu-library/",
						"content": "senseBox MCU Library\n\nDie senseBox MCU senseBox with MCU. The Library gives easy access to the following features/sensors:\n\n\n  Temperature and Humidity Sensor HDC1080\n  Airpressure and Temperature Sensor BMP280\n  Light Visible + UV TSL45315 and VEML6070\n  Ultrasonic Sensor [HC SR04]\n  SDS011 Fine Particular Sensor SDS011\n  senseBox GPS connected via I2C CAM-M8Q –&gt; need TinyGPSPlus\n  Wifi Connection via WifiBee WINC1500\n  send Data to openSenseMap\n\n\nUsage\n\nInstall via Arduino Library Manager or copy it to your Arduino Library folder. Include to your Arduino Programm via #include \"senseBoxMCU.h\"\n\nClasses and Functions\nThe Library provides to following classes and functions. Create a new instance of the different classes to use the Functions, for example:\n\n#include \"senseBoxMCU.h\"\n\nHDC1080 hdc;\n\n\nNow you have acces to the functions:\n\nhdc.getTemperature();\n\n\nBee\npublic:\n\tBee();\n\t\tuint8_t connectToWifi(char* ssid, char* password);\n\t\tvoid startAP(char* ssid);\n\t\tchar* getSsid();\n\t\tchar* getPassword();\n\t\tchar* getIpAddress();\n\n\nOpenSenseMap\nClassname: OpenSenseMap\n\nfunctions public:\n\t\t\tOpenSenseMap(const char* boxId, Bee* bee, const char* host);\n\t\t\tvoid uploadMeasurement(float value, char* sensorID);\n\t\t\tvoid uploadMobileMeasurement(float value, char* sensorID, float lat, float lng);\n\t\t\tvoid setUploadInterval(unsigned int);\n\n\nSDS011\nClassname: SDS011\n\nfunctions public:\n\t\t\tSDS011(Stream&amp; serial);\n\t\t\tfloat getPm10(void);\n\t\t\tfloat getPm25(void);\n\n\nHDC1080\nClassname: HDC1080\n\nfunctions public:\n\t\t\tuint8_t begin(void);\n\t\t\tdouble getTemperature(void);\n\t\t\tdouble getHumidity(void); \n\n\nVEML6070\nClassname: TSL45315\n\nfunctions public:\n\t\t\tuint8_t begin(void);\n\t\t\tdouble getUvIntensity(void);\n\n\nTSL45315\nClassname: TSL45315\n\nfunctions public:\n\t\t\tuint8_t begin(void);\n\t\t\tunsigned long getIlluminance(void); \n\n\nUltrasonic\nClassname: Ultrasonic\n\nfunctions public:\n\t\t\tUltrasonic(int rx, int tx);\n        \tlong getDistance(void);\n\n\nBMP280\nClassname: BMP280\n\nfunctions public:\n\t\t\tbool  begin();\n\t\t\tfloat getTemperature(void);\n\t\t\tfloat getPressure(void);\n\t\t\tfloat getAltitude(float seaLevelhPa = 1013.25);\n\n\nGPS\nClassname: GPS\n\nfunctions public:\n\t\t\tvoid begin();\n\t\t\tfloat getLatitude();\n\t\t\tfloat getLongitude();\n\t\t\tfloat getAltitude();\n\t\t\tfloat getSpeed();\n\t\t\tfloat getHdop();\n\t\t\tfloat getDate();\n\t\t\tfloat getTime();\n\n\nMic\n\n\nClassname: Microphone\n\nfunctions public: \n\t\tMicrophone (int pin);\n\t\tfloat getValue();\n\n\nBMX\n\n\nClassname BMX055\n\nfunctions\tpublic:\n\t\tuint8_t beginAcc(char range);\n\t\tuint8_t beginGyro(void);\n\t\tuint8_t beginMagn(void);\n\t\tvoid getAcceleration(float *x, float *y, float *z, float *accTotal);\n\t\tvoid getMagnet(int *x, int *y, int *z);\n\t\tvoid getRotation(int *x, int *y, int *z);\n\n\nButton\n\n\nClassname Button\n\nfunctions public: \n\t\tButton(int pin);\n\t\tvoid begin();\n\t\tbool getSwitch();\n\t\tbool isPressed();\n\t\tbool wasPressed();"
					}
					
				
			
		
			
				
					,
					
					"allgemein-allgemein-blockly": {
						"id": "allgemein-allgemein-blockly",
						"title": "Blockly für senseBox",
						"categories": "Allgemein",
						"url": " /allgemein/allgemein-blockly/",
						"content": "Verwendung\n\nBlockly für senseBox ist eine grafische Programmieroberfläche für die senseBox. Die Oberfläche läuft in allen gängigen Browsern und benötigt keine Softwareinstallation.\n\nCode compilieren und übertragen\n\nIst dein Programm fertig kannst du es mit einem Klick auf den orangenen “Kompilieren”-Button oben rechts herunterladen.\n\nVerbinde zuerst die MCU mit Hilfe des USB-Kabels mit deinem Computer. Die senseBox MCU hat zwei verschiedene Modi: Den Programm- und den Lern-Modus. Standardmäßig befindet sich die MCU im Programm-Modus. In diesem führt sie das zuletzt übertragende Programm aus. Du erkennst den Program-Modus daran, dass die LED auf der MCU grün leuchten. Bevor nun ein neues Programm übertragen weren kann, muss die MCU in den Lern-Modus versetzt werden. Dies geschieht durch einen Doppelklick auf den roten “Reset”-Button auf der MCU. Du erkennst den Lern-Modus daran, dass nur eine LED direkt neben der “Reset”-Knopf rot leuchtet. Im Lern-Modus wird die senseBox außerdem als Wechseldatenträger erkannt."
					}
					
				
			
		
			
				
					,
					
					"allgemein-allgemein-arduino-ide-installieren": {
						"id": "allgemein-allgemein-arduino-ide-installieren",
						"title": "Installation der Arduino IDE",
						"categories": "Allgemein",
						"url": " /allgemein/allgemein-arduino-ide-installieren/",
						"content": "Arduino IDE installieren\n\nBevor die senseBox aktiviert werden kann, musst du Treiber sowie eine Software auf deinem Computer installieren. Außerdem ist es vor Inbetriebnahme der senseBox ratsam einen Testlauf durchzuführen, um zu überprüfen ob die Sensoren korrekt funktionieren und die Kommunikation mit dem Internet reibungslos läuft.\n\nSchau dir die Anleitung für dein Betriebsystem an und folge den angegebenen Schritten.\n\nArduino Software für Windows herunterladen\n\n\n  Bitte benutze Arduino Version 1.8.7 für einen reibungslosen Ablauf.\n\n\nDie senseBox ist ein Microcontroller mit verschiedenen Komponenten und Sensoren. Sie wird über die Entwicklungsumgebung Arduino IDE programmiert. Lade die Version 1.8.7 von der Arduino Homepage herunter:\n\n\n\nArduino ist ein Open-Source Projekt und wird durch Spenden finanziert. Daher wirst du vor dem Download nach einer Spende gefragt; das kannst du überspringen, indem du auf JUST DOWNLOAD klickst.\n\n\n\n\n \t\n \tLade bitte die ZIP Datei herunter und  nicht  den Windows-Installer um mögliche Probleme \n     zu vermeiden !\n\n\nLege auf deiner Festplatte einen neuen Ordner an und entpacke darin die zip-Datei. Durch das Starten der Datei arduino.exe kann die IDE gestartet werden.\n\nArduino Software für Mac(OSX) herunterladen\n\n\n  Bitte benutze Arduino Version 1.8.7 für einen reibungslosen Ablauf.\n\n\nDie senseBox ist ein Microcontroller mit verschiedenen Komponenten und Sensoren. Sie wird über die Entwicklungsumgebung Arduino IDE programmiert.  Lade die Version 1.8.7 von der Arduino Homepage herunter:\n\n\n\nArduino ist ein Open-Source Projekt und wird durch Spenden finanziert. Daher wirst du vor dem Download nach einer Spende gefragt; das kannst du überspringen, indem du auf JUST DOWNLOAD klickst.\n\n\n\nIn deinem Downloads-Ordner sollte eine Arduino.app Datei erscheinen. Verschiebe diese Datei in deinen “Programme”-Ordner. Durch starten der Datei Arduino.app kann die IDE gestartet werden.\n\nArduino Software für Linux herunterladen\n\n\n  Bitte benutze Arduino Version 1.8.7 für einen reibungslosen Ablauf.\n\n\nDie senseBox ist ein Microcontroller mit verschiedenen Komponenten und Sensoren. Sie wird über die Entwicklungsumgebung Arduino IDE programmiert.  Lade die Version 1.8.7 von der Arduino Homepage herunter:\n\n\n\nArduino ist ein Open-Source Projekt und wird durch Spenden finanziert. Daher wirst du vor dem Download nach einer Spende gefragt; das kannst du überspringen, indem du auf JUST DOWNLOAD klickst.\n\n\nInstallation der IDE unter Linux\n\nLinux-Nutzer können die Linuxvariante herunterladen und entpacken. Das enthaltene install.sh-Skript legt automatisch eine Desktopverknüpfung an. Am schnellsten geht dies über den Terminal. Öffne dazu den Terminal in dem du die Tasten Ctrl + Alt + T drückst und gib dort die folgenden Befehle ein:\n\n# sollte die heruntergeladene Datei nicht im Downloads-Ordner abgespeichert sein, ersetze \"Downloads\" durch den Pfad zum entsprechenden Ordner\ncd Downloads \n\n\n# entpacke die Datei mit folgendem Befehl und installiere Arduino\ntar -xvf arduino-1.8.7-linux64.tar.xz\ncd arduino-1.8.7\n./install.sh\n\nUm den Arduino programmieren zu können, sind unter Ubuntu 14 &amp; 16 zusätzliche Rechte notwendig. Diese können für den aktuellen Nutzer mit den folgenden Befehlen eingerichtet werden (benötigt Admin-Rechte):\n\nFühre udevadm monitor --udev aus und schließe den Arduino per USB an, um die Device-ID zu bestimmen. Der angegebene Bezeichnung am Ende der Ausgabe (zB. ttyUSB0) ist die Device-ID. Beende udevadm per ctrl+C, und führe noch die folgenden Befehle aus, wobei die herausgefundene Device-ID eingesetzt werden muss:\n\nsudo usermod -a -G dialout $(whoami)\nsudo chmod a+rw /dev/&lt;device-id&gt;\n\n\nNach einem Logout und erneutem Login sollte der Arduino aus der Arduino IDE programmierbar sein!"
					}
					
				
			
		
			
				
					,
					
					"t-c3-bcftelakademie-tueftelakademie-was-ist-die-sensebox": {
						"id": "t-c3-bcftelakademie-tueftelakademie-was-ist-die-sensebox",
						"title": "Was ist die senseBox?",
						"categories": "Tüftelakademie",
						"url": " /t%C3%BCftelakademie/tueftelakademie-was-ist-die-sensebox/",
						"content": ""
					}
					
				
			
		
			
				
					,
					
					"t-c3-bcftelakademie-tueftelakademie-umwelt-computer": {
						"id": "t-c3-bcftelakademie-tueftelakademie-umwelt-computer",
						"title": "senseBox - Bringe deine Umwelt in den Computer",
						"categories": "Tüftelakademie",
						"url": " /t%C3%BCftelakademie/tueftelakademie-umwelt-computer/",
						"content": ""
					}
					
				
			
		
			
				
					,
					
					"t-c3-bcftelakademie-tueftelakademie-so-funktionierts": {
						"id": "t-c3-bcftelakademie-tueftelakademie-so-funktionierts",
						"title": "senseBox - So funktioniert's",
						"categories": "Tüftelakademie",
						"url": " /t%C3%BCftelakademie/tueftelakademie-so-funktionierts/",
						"content": ""
					}
					
				
			
		
			
				
					,
					
					"t-c3-bcftelakademie-tueftelakademie-programmierung-umweltdatenstation": {
						"id": "t-c3-bcftelakademie-tueftelakademie-programmierung-umweltdatenstation",
						"title": "senseBox - Programmierung Umweltdatenstation",
						"categories": "Tüftelakademie",
						"url": " /t%C3%BCftelakademie/tueftelakademie-programmierung-umweltdatenstation/",
						"content": ""
					}
					
				
			
		
			
				
					,
					
					"t-c3-bcftelakademie-tueftelakademie-aufbau-umweltdatenstation": {
						"id": "t-c3-bcftelakademie-tueftelakademie-aufbau-umweltdatenstation",
						"title": "senseBox - Aufbau Umweltdatenstation",
						"categories": "Tüftelakademie",
						"url": " /t%C3%BCftelakademie/tueftelakademie-aufbau-umweltdatenstation/",
						"content": ""
					}
					
				
			
		
			
				
					,
					
					"sensebox-home-home-aufbau-video": {
						"id": "sensebox-home-home-aufbau-video",
						"title": "senseBox:home Aufbauvideo",
						"categories": "senseBox:home",
						"url": " /sensebox:home/home-aufbau-video/",
						"content": "Dieses Tutorial zeigt dir den Zusammenbau deiner senseBox:home.\nDas Video ist in verschiedene Kapitel unterteilt, über die Links kannst du direkt zu den Kapiteln springen:\n\nEinsetzten der senseBox MCU in das Gehäuse: 0:10\nAufsetzten des WiFi-Bees: 0:46\nAufbau des Strahlenschutzgehäuses mit Temperatur- und Luftfeuchtigskeitssensor: 1:18\nAufbau des Feinstaub-Sensors (SDS011): 2:18\nAnbindung der außenliegenden Sensoren und des USB-Kabels: 4:34\nAnbindung der Montageebene für Sensoren im Gehäuse. Anschluss des Luftdruck und Licht-Sensors: 5:56\nLetzte Schritte: 7:49"
					}
					
				
			
		
	};
</script>
<script src="/js/lunr.min.js"></script>
<script src="/js/search.js"></script>
		</div>
	</section>

	<footer>
	<div class="wrapper">
		<ul class="footer-links">
			
			<li><a target="_blank" 
					href="https://facebook.com/cloudcannon"
					class="Facebook-icon" >
					
					
		<svg class="facebook" fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M19,4V7H17A1,1 0 0,0 16,8V10H19V13H16V20H13V13H11V10H13V7.5C13,5.56 14.57,4 16.5,4M20,2H4A2,2 0 0,0 2,4V20A2,2 0 0,0 4,22H20A2,2 0 0,0 22,20V4C22,2.89 21.1,2 20,2Z" /></svg>
	

					
					</a></li>
			
			<li><a target="_blank" 
					href="https://twitter.com/sensebox_de"
					class="Twitter-icon" >
					
					
		<svg class="twitter" fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M22.46,6C21.69,6.35 20.86,6.58 20,6.69C20.88,6.16 21.56,5.32 21.88,4.31C21.05,4.81 20.13,5.16 19.16,5.36C18.37,4.5 17.26,4 16,4C13.65,4 11.73,5.92 11.73,8.29C11.73,8.63 11.77,8.96 11.84,9.27C8.28,9.09 5.11,7.38 3,4.79C2.63,5.42 2.42,6.16 2.42,6.94C2.42,8.43 3.17,9.75 4.33,10.5C3.62,10.5 2.96,10.3 2.38,10C2.38,10 2.38,10 2.38,10.03C2.38,12.11 3.86,13.85 5.82,14.24C5.46,14.34 5.08,14.39 4.69,14.39C4.42,14.39 4.15,14.36 3.89,14.31C4.43,16 6,17.26 7.89,17.29C6.43,18.45 4.58,19.13 2.56,19.13C2.22,19.13 1.88,19.11 1.54,19.07C3.44,20.29 5.7,21 8.12,21C16,21 20.33,14.46 20.33,8.79C20.33,8.6 20.33,8.42 20.32,8.23C21.16,7.63 21.88,6.87 22.46,6Z" /></svg>
	

					
					</a></li>
			
			<li><a target="_blank" 
					href="https://youtube.com/c/cloudcannon"
					class="YouTube-icon" >
					
					
		<svg class="youtube" fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M10,16.5V7.5L16,12M20,4.4C19.4,4.2 15.7,4 12,4C8.3,4 4.6,4.19 4,4.38C2.44,4.9 2,8.4 2,12C2,15.59 2.44,19.1 4,19.61C4.6,19.81 8.3,20 12,20C15.7,20 19.4,19.81 20,19.61C21.56,19.1 22,15.59 22,12C22,8.4 21.56,4.91 20,4.4Z" /></svg>
	

					
					</a></li>
			
			<li><a target="_blank" 
					href="https://instagram.com/"
					class="Instagram-icon" >
					
					
		<svg class="instagram" fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7.8,2H16.2C19.4,2 22,4.6 22,7.8V16.2A5.8,5.8 0 0,1 16.2,22H7.8C4.6,22 2,19.4 2,16.2V7.8A5.8,5.8 0 0,1 7.8,2M7.6,4A3.6,3.6 0 0,0 4,7.6V16.4C4,18.39 5.61,20 7.6,20H16.4A3.6,3.6 0 0,0 20,16.4V7.6C20,5.61 18.39,4 16.4,4H7.6M17.25,5.5A1.25,1.25 0 0,1 18.5,6.75A1.25,1.25 0 0,1 17.25,8A1.25,1.25 0 0,1 16,6.75A1.25,1.25 0 0,1 17.25,5.5M12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9Z" /></svg>
	

					
					</a></li>
			
		</ul>
		<p class="copyright">&copy; Base 2020. All rights reserved.<a
				href="https://sensebox.de/de/imprint"> Impressum</a></p>
	</div>
</footer>
	<script>
		$(function () {
			$('a[href*=\\#]').not(".no-smooth").on('click', function (event) {
				var el = $(this.hash);
				if (el.length > 0) {
					// event.preventDefault();
					$('html,body').animate({ scrollTop: $(this.hash).offset().top - 50 }, 500);
				}
			});

			$('svg').click(function () {
				$(this).parent('form').submit();
			});
		});

		document.getElementById("open-nav").addEventListener("click", function (event) {
			event.preventDefault();
			document.body.classList.toggle("nav-open");
		});
	</script>
</body>

</html>